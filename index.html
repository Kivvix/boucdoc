<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Josselin Massot" />
  <title>Modèles hybrides fluide/cinétique pour les plasmas chauds</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="template/style/pandoc.css" />
  <link rel="stylesheet" href="template/style/boucdoc.css" />
  <script src="https://cdn.jsdelivr.net/npm/katex@0.10.0-beta/dist/katex.min.js"></script><script src="https://cdn.jsdelivr.net/npm/katex@0.10.0-beta/dist/contrib/auto-render.min.js"></script><script>document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body);
  });</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-beta/dist/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<a id="top" ></a>
<!--
<nav>
  <h1>Truc machin</h1>

  <ul>
    <li><a href="#" class="button" >lien 1</a></li>
    <li><a href="#" class="button" >lien 2</a></li>
    <li><a href="#" class="button" >lien 3</a></li>
    <li><a href="#" class="button" >lien 4</a></li>
  </ul>
</nav>
-->
<header>
<h1 class="title">Modèles hybrides fluide/cinétique pour les plasmas chauds</h1>
<p class="author">Josselin Massot</p>
</header>
<h1 id="introduction">Introduction</h1>
<p>La simulation numérique fut introduite dès l’émergence de l’informatique pour enrichir les connaissances scientifiques dans des contextes où l’expérimentation est trop contraignante voir impossible, il peut donc être difficile de valider les résultats des simulations. La simulation peut aussi avoir un intérêt prédictif pour dimensionner un problème physique (simulation de tokamak avant leur construction dans le projet ITER) ou pour tester un modèle et le confronter aux futurs observations (simulation de nébuleuses ou d’étoiles). La simulation peut être vue comme une retranscription informatique de modèles mathématiques, sensés représenter des phénomènes physiques. La simulation numérique doit être représentative de la réalité, dans des modèles où la solution exacte est souvent hors de portée, il est nécessaire de vérifier que la transcription numérique conserve les propriétés mathématiques du modèle (conservation de certaines quantités physiques comme la masse ou l’énergie totale par exemple).</p>
<p>Un enjeu majeur de la modélisation et de la simulation est de maintenir un équilibre entre les approximations permettant d’accélérer le temps de traitement et la représentativité des résultats.</p>
<p>Notre étude s’effectue sur un système de particules au sein d’un gaz raréfié ou d’un plasma chaud. Un plasma, qualifié de 4e état de la matière (en plus de solide liquide et gaz), est un état de la matière dans lequel différentes charges électriques circulent. Ces charges sont des électrons (charge négative), particules qui sont extraites des atomes ; et des ions (charge positive), particules qui résultent de l’extraction des électrons. Le plasma est généralement obtenu en chauffant un gaz à très haute température, ce qui permet d’exciter les particules le constituant et d’arracher des électrons aux atomes. La température, grandeur macroscopique, exprime l’agitation des particules et donc leur vitesse propre (grandeur microscopique) ; le qualificatif <em>chaud</em> indique donc que des particules ont des vitesses élevées au sein du plasma. L’étude des plasmas possède de nombreuses applications dans le domaine industriel, tels que la propulsion par plasmas (astronautique), la fusion nucléaire (énergie) et la découpe (industrie).</p>
<p>Pour décrire un tel système de particules, plusieurs possibilités existent. La description dite fluide, qui prend en compte les équations de la mécanique des fluides (comme les équations d’Euler ou de Navier-Stokes) peut être utilisée. Les inconnues de ces équations sont des quantités dites macroscopiques (mesurables expérimentalement) comme la densité, la vitesse moyenne ou la température qui ne dépendent que du temps et de la position. Cependant cette description suppose que le système étudié est à l’équilibre, c’est-à-dire que la répartition en vitesse des particules est maxwellienne. Or lorsque le système est parcouru par une onde de choc ou lorsque une population de particules chaudes est présente dans le système, des phénomènes hors équilibre sont à prendre en compte exigeant une description plus précise. On utilise alors la description cinétique. Celle-ci manipule une fonction de distribution dépendant du temps, de l’espace mais aussi de la vitesse des particules, ce qui permet de prendre en compte ces aspects hors équilibre. La complexité de description apportée par le modèle cinétique se traduit numériquement par un coût en temps de calcul et utilisation de la mémoire ; en effet la simulation s’effectue avec les variables <span class="math inline">\((t,x,v)\)</span> donc <span class="math inline">\(7\)</span> dimensions au lieu de seulement 4 dimensions pour la description fluide, où les inconnues ne dépendent que de <span class="math inline">\((t,x)\)</span>. L’espace mémoire nécessaire pour stocker <span class="math inline">\(f(t=0,x,v)\)</span> sur une grille <span class="math inline">\(100^6\)</span> de l’espace des phases peut être estimé à 7.2To, alors que la description fluide ne nécessite que 7.6Mo sur une grille <span class="math inline">\(100^3\)</span> de l’espace. Une description cinétique n’est donc pas souhaitable sur tout le domaine d’étude si le fluide est proche de son équilibre et des optimisations sont donc envisageable.<br />
Nous souhaitons développer des modèles hybrides mêlant les avantages des descriptions fluide et cinétique. Notre approche se rapproche des méthodes dites de <em>décomposition de domaines</em> pour lesquelles le modèle fluide est utilisé dans les zones où le système est à l’équilibre alors que le modèle cinétique est utilisé uniquement dans les zones où le système est hors équilibre (dans le choc par exemple), approche déjà étudiée dans <span class="citation" data-cites="BENNOUNE20083781">[1]</span>, <span class="citation" data-cites="dimarco">[2]</span> ou <span class="citation" data-cites="filbet">[3]</span>.</p>
<p>Une part importante de l’étude de ce stage fut consacrée à l’étude et l’implémentation des méthodes numériques de type eulériennes, c’est-à-dire utilisant une grille dans l’espace des phases <span class="math inline">\((x,v)\)</span>.<br />
Il est intéressant, voir crucial, numériquement de développer des méthodes d’ordre élevé pour capturer les forts gradients pouvant être générés par la solution (présence de structures fines dans l’espace des phases ou de choc), cela permet aussi de limiter la diffusion numérique qui dégrade les résultats sur des temps longs. L’erreur d’une méthode d’ordre <span class="math inline">\(m\)</span> est divisée par <span class="math inline">\(2^m\)</span> lorsque l’on double le nombre de points du maillage, alors que le temps de calcul évoluera de manière plus linéaire en fonction du nombre de points, ainsi une méthode d’ordre élevé avec peu de points devient préférable à une méthode d’ordre faible avec plus de points.<br />
Dans des conditions physiques réalistes, il est nécessaire de prendre en compte des conditions aux bords de type Dirichlet ou Neumann. Ces conditions peuvent être délicates à exprimer pour des méthodes d’ordre élevées. Ainsi, même si la majorité de l’étude est consacrée à des conditions aux bords périodiques, un des enjeux de ce stage fut d’implémenter les conditions aux bords de type Neumann.</p>
<p>Ce stage a été consacré à l’étude, la dérivation et la validation numérique de modèles hybrides fluide-cinétique en les comparant de façon systématique aux modèles d’Euler (fluide) et cinétique. L’objectif est de construire un modèle et d’écrire un code pour résoudre efficacement des problèmes dans lesquels des régions où le système est hors équilibre. Ainsi on se propose d’obtenir d’obtenir un modèle couplé fluide-cinétique où le modèle cinétique, plus coûteux, n’est utilisé que pour la région dite <em>hors équilibre</em>, alors que le modèle fluide sera utilisé pour le reste du domaine qui lui, est à l’équilibre thermodynamique. Ce type d’approche en décomposition de domaine nécessite habituellement des conditions pour coupler le modèle cinétique et fluide, ce qui peut s’avérer difficile au niveau mathématique et numérique. Dans ce travail, la transition fluide-cinétique est assurée par une fonction de transition <span class="math inline">\(h(t,x)\)</span> qui dégénère automatiquement et qui permet de s’affranchir du traitement délicat des conditions de bords couplant les modèles fluide et cinétique. À partir d’un modèle <em>micro-macro</em> équivalent au problème cinétique contenant une raideur en <span class="math inline">\(\frac{1}{\varepsilon}\)</span>, <span class="math inline">\(\varepsilon\in ]0,1]\)</span><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>, la fonction de transition <span class="math inline">\(h\)</span> est introduite ; la partie <em>micro</em> corespondante à la zone à l’équilibre est alors négligée. Ce modèle hybride fluide-cinétique est alors approché numériquement à l’aide de méthodes d’ordre élevé en <span class="math inline">\((x,v)\)</span> (schéma compact ou WENO) alors qu’une discrétisation particulière en temps a dû être utilisée pour garantir une stabilité uniforme par rapport à <span class="math inline">\(\varepsilon\)</span>.</p>
<p>Ce stage s’est essentiellement consacré à l’étude de la construction des modélisations hybrides, l’écriture et l’utilisation de méthodes d’ordre élevé (tel que les schémas compacts ou WENO) en prenant en compte différentes conditions aux bords. Une décomposition de domaine avec l’introduction d’une fonction indicatrice <span class="math inline">\(h(t,x)\)</span> a pu être effectué à l’aide des travaux dans <span class="citation" data-cites="dimarco">[2]</span>. Une attention toute particulière a été portée sur la gestion d’un terme raide en <span class="math inline">\(\frac{1}{\varepsilon}\)</span> introduit par le modèle cinétique.</p>
<p>Ainsi nous présenterons dans un premier temps les modèles classiques de la littérature, cinétique et fluide, en indiquant leurs avantages et leurs défauts. Nous construirons ensuite un modèle hybride permettant de lier les forces des différentes descriptions du problème. Nous nous intéresserons par la suite à différents schémas numériques d’ordre élevé permettant de résoudre le système, pour enfin présenter nos résultats numériques sur plusieurs cas tests issus de la dynamique des gaz et des plasmas.</p>
<h1 id="présentation-des-modèles">Présentation des modèles</h1>
<p>Dans cette partie, nous présenterons différents modèles mathématiques utilisés dans la littérature pour décrire un système de particules, potentiellement chargées. Ces modèles vont de la description particulaire, qui est la plus précise, jusqu’à la description hydrodynamique, en passant par la description cinétique.</p>
<h2 id="modèle-microscopique-particulaire">Modèle microscopique particulaire</h2>
<p>Les modèles microscopiques fonctionnent sur le principe de l’étude newtonienne de particules. Un tel modèle cherche à déterminer la trajectoire de chaque particule par le principe fondamental de la dynamique, d’où le système :</p>
<p><span class="math display">\[
  \begin{cases}
    \dot{x}_i (t) = v_i(t) \\
    \dot{v}_i (t) = \displaystyle\sum_{j \atop j \ne i} F_{ji}(t,x_i(t))
  \end{cases}
\]</span></p>
<p>où <span class="math inline">\(x_i(t)\)</span> et <span class="math inline">\(v_i(t)\)</span> représentent respectivement la position et la vitesse au temps <span class="math inline">\(t \geq 0\)</span> de la <span class="math inline">\(i\)</span>-ème particule avec <span class="math inline">\(i=1,\dots,n\)</span> où <span class="math inline">\(n\)</span> est le nombre de particules. <span class="math inline">\(F_{ji}\)</span> représente la force exercée par la particule <span class="math inline">\(j\)</span> sur <span class="math inline">\(i\)</span>, cela permet d’expliquer la contrainte de sommation <span class="math inline">\(j \ne i\)</span>. La force considérée dans ce modèle peut être l’interaction coulombienne pour représenter l’interaction électrostatique entre particules, ou la force gravitationnelle pour représenter l’interaction à grande distance entre masses.</p>
<p>La variable de base dans le modèle est le temps <span class="math inline">\(t\)</span> ; à chaque pas de temps on calcule la somme des forces pour obtenir l’accélération. La vitesse puis la position s’obtiennent par intégration successive.</p>
<p>Ce modèle est très coûteux en temps de calcul puisqu’il possède une complexité algorithmique en <span class="math inline">\(\mathcal{O}(2^n)\)</span>. L’utilisation de ce type de modèle est inenvisageable dès que le nombre de particules <span class="math inline">\(n\)</span> atteint la centaine. Dans le cadre de l’étude des plasmas, le nombre <span class="math inline">\(n\)</span> de particules en interaction est voisin du nombre d’Avogadro <span class="math inline">\(\mathcal{N}_A \approx 6,02\cdot 10^{23}\)</span>.</p>
<p>Une approximation de ce modèle est parfois utilisé à l’aide d’une représentation arborescente de l’espace via un <em>quadtree</em>, ou <em><span class="math inline">\(kd\)</span>-tree</em> par exemple ; cela permet de négliger les interactions à plus longue distance. C’est ce qui est par exemple utilisé dans des simulations de galaxies, ou dans des moteurs de collision comme celui du jeu vidéo <em>Doom</em>.</p>
<h2 id="modèle-macroscopique">Modèle macroscopique</h2>
<p>Les modèles macroscopiques sont très utilisés en mécanique des fluides ; le système d’équations dépend alors de peu de variables physiques pour d’écrire l’état thermodynamique. Ces variables sont condensées en un seul vecteur de variables extensives <span class="math inline">\(U\)</span>, mettant en jeu des variables thermodynamiques comme :</p>
<p><span class="math display">\[
  (\rho,u,T,\dots)(t,x)
\]</span></p>
<p>où <span class="math inline">\(\rho\)</span> désigne la densité, <span class="math inline">\(u\)</span> la vitesse moyenne et <span class="math inline">\(T\)</span> la température au temps <span class="math inline">\(t\geq 0\)</span> à la position <span class="math inline">\(x\)</span> ; <span class="math inline">\(U\)</span> vérifie les équations d’Euler :</p>
<p><span class="math display">\[
  \partial_t U + \nabla_x\cdot \mathcal{F}(U) = 0
\]</span><a href="#2.1" id="2.1" class="eq"></a></p>
<p>où la fonction <span class="math inline">\(\mathcal{F}\)</span> désigne le flux.</p>
<p>Les variables de bases du problème sont <span class="math inline">\(t\)</span> et <span class="math inline">\(x\)</span>. La simulation n’impose que 4 dimensions, une de temps et 3 d’espace ; donc dans une région se comportant globalement comme un fluide il est privilégié d’utiliser ce type de méthode, moins coûteuse en temps de calcul qu’un modèle microscopique ou cinétique.</p>
<p>Dans le cadre des équations d’Euler, <span class="math inline">\(U\)</span> est défini par :</p>
<p><span class="math display">\[
  U = \begin{pmatrix}
    \rho   \\
    \rho u \\
    e
  \end{pmatrix}
\]</span></p>
<p>où <span class="math inline">\(e\)</span> est l’énergie interne et est relié à la température via <span class="math inline">\(e = \frac{\rho T}{2}+ \frac{\rho u^2}{2}\)</span>. Le vecteur <span class="math inline">\(U\)</span> vit dans <span class="math inline">\(\mathbb{R}^{d+2}\)</span> car <span class="math inline">\(\rho \in \mathbb{R}\)</span>, <span class="math inline">\(e\in\mathbb{R}\)</span> et <span class="math inline">\(u\in\mathbb{R}^d\)</span>. Le flux <span class="math inline">\(\mathcal{F}\)</span> est alors défini en dimension <span class="math inline">\(d\)</span> par :</p>
<p><span class="math display">\[
  \mathcal{F}(U) = \begin{pmatrix}
    \rho u       \\
    \rho u\otimes u + p \mathbb{I}_d \\
    u(e+p)
  \end{pmatrix}
\]</span></p>
<p>où <span class="math inline">\(u\otimes u\)</span> désigne le produit tensoriel de <span class="math inline">\(u\)</span> avec lui-même, <em>i.e.</em> un simple produit lorsque <span class="math inline">\(d=1\)</span> ou la matrice <span class="math inline">\((u\otimes u)_{ij} = u_iu_j\)</span> sinon ; <span class="math inline">\(\mathbb{I}_d\)</span> est la matrice identité et la pression <span class="math inline">\(p\)</span> est calculée en fonction des inconnues par la relation :</p>
<p><span class="math display">\[
  p = 2(e - \frac{1}{2}\rho |u|^2)
\]</span></p>
<p>En dimension <span class="math inline">\(d \ne 1\)</span> le flux <span class="math inline">\(\mathcal{F}(U)\)</span> n’est plus un vecteur mais une matrice. En prenant la divergence du flux : <span class="math inline">\(\nabla_x\cdot\mathcal{F}(U)\)</span>, on retrouve bien un vecteur à <span class="math inline">\(d+2\)</span> dimensions. En effet la première et dernière composante sont de simples scalaires, donc leur dérivée est aussi un scalaire ; la seconde composante est une matrice carrée de taille <span class="math inline">\(d\)</span>, dont la divergence donne bien un vecteur de taille <span class="math inline">\(d\)</span>.</p>
<h3 id="équation-de-poisson">Équation de Poisson</h3>
<p>Dans le contexte de la physique des plasmas, nous étudions le mouvement de particules chargées formant le plasma, c’est-à-dire des électrons et des ions. L’équation de Poisson est un modèle physique de l’évolution du champ électrique moyen <span class="math inline">\(E\)</span> créé par les particules chargées :</p>
<p><span class="math display">\[
  \nabla_x\cdot E = \sum_s q_s \rho_s
\]</span></p>
<p>avec <span class="math inline">\(q_s\)</span> la charge électrique d’une espèce <span class="math inline">\(s\)</span> de particule, <span class="math inline">\(\rho_s\)</span> la densité de cette même espèce <span class="math inline">\(s\)</span>. Dans le cadre du modèle macroscopique présenté précédemment, <span class="math inline">\(\rho\)</span> représente la densité d’électrons, seule espèce chargée considérée comme mouvante ; en effet les ions, beaucoup plus lourds, peuvent être considérés comme statique. Le rapport de masse entre la masse du proton et celle de l’électron est d’environ <span class="math inline">\(\mu=\frac{m_p}{m_e}\approx 1\,836\)</span>, or les ions considérés ne sont pas nécessairement des ions hydrogènes, composés d’un unique proton. En normalisant les charges électriques, l’équation de Poisson peut se réécrire :</p>
<p><span class="math display">\[
  \nabla_x \cdot E = \rho -1
\]</span><a href="#2.2" id="2.2" class="eq"></a></p>
<p>où <span class="math inline">\(\rho\)</span> est la densité d’électrons et le terme <span class="math inline">\(1\)</span> représente la densité ionique normalisée. En rajoutant le terme de force induit par le champ électrique <span class="math inline">\(E\)</span>, l’équation (<a href="#2.1" class="aeq">2.1</a>) devient :</p>
<p><span class="math display">\[
  \partial_t U + \nabla_x\cdot\mathcal{F}(U) = S(U)
\]</span></p>
<p>Le terme source <span class="math inline">\(S(U)\)</span> est nul dans le cadre des équations d’Euler en l’absence d’un champ électrique <span class="math inline">\(E\)</span>, en présence de celui-ci le terme s’explicite sous la forme suivante :</p>
<p><span class="math display">\[
  S(U) = \begin{pmatrix} 0 \\ \rho E \\ 2\rho uE \end{pmatrix}
\]</span></p>
<h2 id="modèle-cinétique">Modèle cinétique</h2>
<p>Le principe du modèle cinétique est de proposer une description intermédiaire entre le modèle microscopique et macroscopique. On représente les particules dans l’espace des phases <span class="math inline">\((x,v)\)</span>, où <span class="math inline">\(x \in \Omega \subset \mathbb{R}^d\)</span> désigne la position et <span class="math inline">\(v \in \mathbb{R}^d\)</span> la vitesse, avec <span class="math inline">\(d=1,2,3\)</span> la dimension du problème. L’étude se restreint au cas de <span class="math inline">\(\Omega\)</span> un fermé borné de <span class="math inline">\(\mathbb{R}^d\)</span> ; la vitesse quant à elle n’est <em>a priori</em> pas bornée.</p>
<p>Nous n’étudions pas chaque particule individuellement mais, à la manière du modèle macroscopique, une valeur statistique qu’est la fonction de distribution de particules dans l’espace des phases notée <span class="math inline">\(f\)</span>. La grandeur <span class="math inline">\(f(t,x,v)\mathrm{d}x\mathrm{d}v\)</span> représente la densité de particules dans un volume élémentaire de l’espace des phases <span class="math inline">\(\mathrm{d}x\mathrm{d}v\)</span> centré en <span class="math inline">\((x,v)\)</span> au temps <span class="math inline">\(t \geq 0\)</span>.</p>
<p>L’inconnue <span class="math inline">\(f(t,x,v)\)</span> est alors solution d’une équation de transport dans l’espace des phases à laquelle on ajoute un terme de collision :</p>
<p><span class="math display">\[
  \partial_t f + v\cdot\nabla_x f = Q(f)
\]</span><a href="#2.3" id="2.3" class="eq"></a></p>
<p>où le transport s’effectue à vitesse <span class="math inline">\(v\)</span> dans la direction <span class="math inline">\(x\)</span>. <span class="math inline">\(Q(f)\)</span> représente un opérateur quadratique de collision, il modélise les interactions binaires entre particules ; plusieurs expressions sont possibles comme l’opérateur de Boltzmann pour les gaz raréfiés, ou les opérateurs Landau ou BGK par exemple pour le cas des particules chargées.</p>
<p>Les variables de base du problème sont <span class="math inline">\(t\)</span>, <span class="math inline">\(x\)</span> et <span class="math inline">\(v\)</span>. Une simulation directe du problème complet impose donc de travailler en 7 dimensions : une de temps, et 6 pour l’espace des phases <span class="math inline">\((x,v)\)</span>. Travailler dans un espace de dimension aussi élevée implique des coûts importants en temps de calcul et dans l’utilisation de la mémoire, cela est cependant moins coûteux qu’un modèle microscopique. De plus il est possible de développer des schémas numériques adaptés au problème considéré et réduire le temps de calcul, par exemple via des techniques de décomposition de domaine. En effet un maillage non cartésien permet de ne raffiner que localement le domaine et ainsi réduire le temps de calcul sur certaines régions de l’espace. Mais les contraintes de gestion du maillage nous ont orientés vers une autre alternative.</p>
<p>L’équation cinétique (<a href="#2.3" class="aeq">2.3</a>) possède quelques propriétés qu’il sera utile de vérifier au niveau numérique. Nous les présentons dans la proprosition suivante.</p>
<p>Nous considèrerons un opérateur de collision <span class="math inline">\(Q(f)\)</span> dans l’équation (<a href="#2.3" class="aeq">2.3</a>) qui conserve la masse, de l’impulsion et de l’énergie lors des collisions :</p>
<p><span class="math display">\[
  \int_{\mathbb{R}^d} m(v)Q(f)\,\mathrm{d}v = 0
\]</span></p>
<p>où <span class="math inline">\(m(v) = ( 1, v , |v|^2 )\)</span>.</p>
<p>La grandeur <span class="math inline">\(f\)</span> représente la densité de particules chargées dans l’espace des phases, donc la grandeur <span class="math inline">\(\iint m(v)f(t,x,v)\,\mathrm{d}x\mathrm{d}v\)</span> est un vecteur dont les composantes correspondent respectivement à la masse totale du système, l’impulsion et l’énergie totale du système.</p>
<blockquote>
<p><strong>Proposition :</strong> L’équation (<a href="#2.3" class="aeq">2.3</a>) préserve la masse, l’impulsion et l’énergie, c’est-à-dire :</p>
<p><span class="math display">\[
\iint_{\Omega\times\mathbb{R}^d} \begin{pmatrix} 1 \\ v \\ |v|^2 \end{pmatrix} f(t,x,v)\,\mathrm{d}x\mathrm{d}v = 0
\]</span></p>
</blockquote>
<p><em>Preuve :</em></p>
<p>En multipliant (<a href="#2.3" class="aeq">2.3</a>) par <span class="math inline">\(m(v)\)</span>, puis en intégrant selon les directions <span class="math inline">\(x\)</span> et <span class="math inline">\(v\)</span> on obtient :</p>
<p><span class="math display">\[
  \iint_{\Omega\times\mathbb{R}^d} m(v)(\partial_t f + v\cdot\nabla_x f)\,\mathrm{d}x\mathrm{d}v = \iint_{\Omega\times\mathbb{R}^d}m(v)Q(f)\,\mathrm{d}x\mathrm{d}v
\]</span></p>
<p>Or les moments de <span class="math inline">\(Q(f)\)</span> sont nuls, et l’intégrale sur tout l’espace de la dérivée en <span class="math inline">\(x\)</span> vaut zéro. On obtient finalement :</p>
<p><span class="math display">\[
  \frac{\mathrm{d}}{\mathrm{d}t}\iint_{\Omega\times\mathbb{R}^d} m(v)f(t,x,v)\,\mathrm{d}x\mathrm{d}v = 0
\]</span><a href="#2.4" id="2.4" class="eq"></a></p>
<h3 id="prise-en-compte-du-champ-électrique">Prise en compte du champ électrique</h3>
<p>De manière analogue au modèle macroscopique, le contexte de l’étude des plasmas nécessite l’ajout des forces induites par le champ électrique moyen <span class="math inline">\(E\)</span>, champ électrique calculé via l’équation de Poisson.</p>
<p>L’équation de Poisson s’écrit dans le modèle cinétique comme :</p>
<p><span class="math display">\[
  \nabla_x \cdot E = \int_{\mathrm{R}^d} f\,\mathrm{d}v - 1
\]</span><a href="#2.5" id="2.5" class="eq"></a></p>
<p>où <span class="math inline">\(f\)</span> est la distribution d’électrons et le terme <span class="math inline">\(1\)</span> représente la densité ionique normalisée. En rajoutant le terme de force induit par le champ électrique <span class="math inline">\(E\)</span>, l’équation du modèle cinétique (<a href="#2.3" class="aeq">2.3</a>) mène à l’équation dite de Vlasov :</p>
<p><span class="math display">\[
  \begin{cases}
    \partial_t f + v\cdot\nabla_x f + E\cdot\nabla_v f = Q(f) \\
    \nabla_x\cdot E = \int_{\mathbb{R}^d} f\,\mathrm{d}v -1
  \end{cases}
\]</span><a href="#2.6" id="2.6" class="eq"></a></p>
<p>Ce modèle est une équation de transport dans l’espace des phases à vitesse <span class="math inline">\(v\)</span> dans la direction <span class="math inline">\(x\)</span> et <span class="math inline">\(E\)</span> dans la direction <span class="math inline">\(v\)</span> avec un terme de collision <span class="math inline">\(Q(f)\)</span>.</p>
<p>On retrouve bien une définition du champ électrique équivalente à (<a href="#2.2" class="aeq">2.2</a>) puisque : <span class="math inline">\(\int_{\mathbb{R}^d}f(t,x,v)\,\mathrm{d}v = \rho(t,x)\)</span>.</p>
<h2 id="cinétique-vers-fluide">Cinétique vers fluide</h2>
<p>Il est possible d’interpréter la description fluide à partir de la description cinétique. Cela permet d’assurer une continuité des modèles entre la description macroscopique et cinétique.</p>
<p>Dans le modèle cinétique (<a href="#2.3" class="aeq">2.3</a>), il est possible de lier la fonction de densité dans l’espace des phases au vecteur de variables extensives <span class="math inline">\(U\)</span> utilisé dans les équations d’Euler via :</p>
<p><span class="math display">\[
  U(t,x) = \int_{\mathbb{R}^d} m(v)f(t,x,v)\,\mathrm{d}v = \begin{pmatrix}\rho \\ \rho u \\ \rho|u|^2 + \frac{d}{2}\rho T\end{pmatrix}(t,x)
\]</span></p>
<p>où <span class="math inline">\(m(v) = (1 \; v \; |v|^2)^{\mathsf{T}}\)</span>, <span class="math inline">\(\rho\)</span> est la densité de particules, <span class="math inline">\(u\)</span> la vitesse moyenne, et <span class="math inline">\(T\)</span> la température. Le vecteur <span class="math inline">\(U\)</span> est de dimension <span class="math inline">\(d+2\)</span> ; en effet la deuxième composante <span class="math inline">\(\rho u\)</span> est un vecteur de dimension <span class="math inline">\(d\)</span> qui s’obtient comme suit :</p>
<p><span class="math display">\[
  \rho u = \int_{\mathbb{R}^d} v  f(v)\,\mathrm{d}v
\]</span></p>
<p>Par la suite nous choisirons pour opérateur de collision <span class="math inline">\(Q(f)\)</span>, l’opérateur simplifié de BGK dans l’équation (<a href="#2.3" class="aeq">2.3</a>) ; celui-ci est défini par :</p>
<p><span class="math display">\[
  Q(f)(t,x,v) = (M_{[f]} - f)(t,x,v)
\]</span></p>
<p>En introduisant le paramètre <span class="math inline">\(\varepsilon \in ]0,1]\)</span> où <span class="math inline">\(\varepsilon = \frac{\ell}{L}\)</span> avec <span class="math inline">\(\ell\)</span> le libre parcours moyen des particules et <span class="math inline">\(L\)</span> la taille du domaine, on obteient</p>
<p><span class="math display">\[
  \partial_t f + v\cdot\nabla_x f = \frac{1}{\varepsilon}(\mathcal{M}_{[f]} - f)
\]</span><a href="#2.7" id="2.7" class="eq"></a></p>
<p>où <span class="math inline">\(\mathcal{M}_{[f]}\)</span> est la distribution de vitesse maxwellienne définie par :</p>
<p><span class="math display">\[
  \mathcal{M}_{[f]} = \frac{\rho}{(2\pi T)^{\frac{d}{2}}}\exp\left(-\frac{|v-u|^2}{2T}\right)
\]</span><a href="#2.8" id="2.8" class="eq"></a></p>
<p>Nous considérons des opérateurs de collisions qui préservent la masse, l’impulsion et l’énergie, cela se traduit par l’équation :</p>
<p><span class="math display">\[
  \int_{\mathbb{R}^d} m(v)Q(f)\,\mathrm{d}v = 0
\]</span></p>
<p>Pour l’opérateur de collision BGK cela signifie :</p>
<p><span class="math display">\[
  \int_{\mathbb{R}^d} m(v)\mathcal{M}_{[f]}\,\mathrm{d}v = \int_{\mathbb{R}^d} m(v)f(v)\,\mathrm{d}v = U(t.x)
\]</span></p>
<p>Pour tenter d’obtenir les équations de la mécanique des fluides à partir de l’équation cinétique, on multiplie l’équation (<a href="#2.7" class="aeq">2.7</a>) par <span class="math inline">\(m(v)\)</span> puis on intègre par rapport à <span class="math inline">\(v\in\mathbb{R}^d\)</span> pour obtenir :</p>
<p><span class="math display">\[
  \partial_t U + \nabla_x\cdot\int_{\mathbb{R}^d}vm(v)f\,\mathrm{d}v = 0
\]</span><a href="#2.9" id="2.9" class="eq"></a></p>
<p>Composante par composante l’équation (<a href="#2.9" class="aeq">2.9</a>) s’écrit avec <span class="math inline">\(d=1\)</span> :</p>
<p><span class="math display">\[
  \partial_t\begin{pmatrix}U_1 \\ U_2 \\ U_3 \end{pmatrix} + \partial_x\cdot\begin{pmatrix}U_2\\ U_3 \\ \int_{\mathbb{R}} v^3f\,\mathrm{d}v \end{pmatrix} = 0
\]</span><a href="#2.10" id="2.10" class="eq"></a></p>
<p>où on a noté le vecteur <span class="math inline">\(U\)</span> par composante : <span class="math inline">\(U = (U_1,U_2,U_3)^{\mathsf{T}} = (\rho,rho u,e)^{\mathsf{T}}\)</span>. Pour obtenir un modèle fermé en <span class="math inline">\(U\)</span>, il faut faire une hypothse sur la forme de <span class="math inline">\(f\)</span> par rapport à <span class="math inline">\(v\)</span> afin de pouvoir exprimer <span class="math inline">\(\int_{\mathbb{R}}v^3f\,\mathrm{D}\)</span> en fonction de <span class="math inline">\(U\)</span>. C’est le problème de fermeture. Une possibilité est d’utiliser le fait que lorsque <span class="math inline">\(\varepsilon \to 0\)</span> on obtient formellement grâce à (<a href="#2.7" class="aeq">2.7</a>) que <span class="math inline">\(f \to \mathcal{M}_{[f]}\)</span> ; on peut donc écrire <span class="math inline">\(f\)</span> comme un développement en <span class="math inline">\(\varepsilon\)</span> comme :</p>
<p><span class="math display">\[
  f(t,x,v) = \mathcal{M}_{[f]}(t,x,v) + \mathcal{O}(\varepsilon)
\]</span></p>
<p>Ainsi on peut fermer le problème (<a href="#2.10" class="aeq">2.10</a>) en approchant <span class="math inline">\(f\)</span> par <span class="math inline">\(\mathcal{M}_{[f]}\)</span>, ce qui permet d’exprimer <span class="math inline">\(\int v^3f\,\mathrm{d}v\)</span> en fonction de <span class="math inline">\(U\)</span> (ou <span class="math inline">\((\rho,u,T)^\mathsf{T}\)</span>). En effet on a <span class="math inline">\(\int v^3\mathcal{M}_{[U]}(v)\,\mathrm{d}v = \rho u^3 + 3\rho Tu\)</span>. On retrouve alors les équations d’Euler.</p>
<p>En prenant en compte les termes d’odre <span class="math inline">\(\varepsilon\)</span> dans le développement de <span class="math inline">\(f\)</span>, on obtient de manière similaire les équations de Navier-Stokes.</p>
<p>Nous obtenons donc un lien entre le modèle cinétique et fluide à la limite <span class="math inline">\(\varepsilon \to 0\)</span>. Ceci permet de valider nos schémas et d’en vérifier les résultats en les comparant à un simulateur de fluide eulérien en fonction des valeurs de <span class="math inline">\(\varepsilon \in ]0,1]\)</span>.</p>
<h1 id="modèles-hybrides-fluides-cinétiques">Modèles hybrides fluides-cinétiques</h1>
<p>Les modèles macroscopiques ne sont pas valides dans des régions localisées du domaine de calcul dites hors équilibre, c’est-a-dire <span class="math inline">\(f \neq \mathcal{M}_{[f]}\)</span>. En effet pour certains problèmes, comme dans les zones de chocs ou les problèmes de couches limites, cette description n’est pas suffisante pour un flux hors d’état d’équilibre. Il n’est pour autant pas nécessaire de résoudre un modèle cinétique sur tout le domaine d’étude, qui est bien plus coûteux en temps de calcul.</p>
<p>Pour tenter d’obtenir un bon compromis entre coût numérique et précision, on se propose de suivre une approche hybride fluide-cinétique. Pour cela, nous allons construire un modèle <em>micro-macro</em>, décrit dans <span class="citation" data-cites="dimarco">[2]</span>, basé sur une décomposition de l’inconnue cinétique <span class="math inline">\(f\)</span> en une partie macroscopique (une distribution maxwellienne) , plus une partie microscopique (l’écart par rapport à l’équilibre thermodynamique). Cette décomposition est similaire à celle décrite dans <span class="citation" data-cites="dimarco">[2]</span> ou <span class="citation" data-cites="crestetto">[4]</span>.</p>
<p>Nous écrivons <span class="math inline">\(f\)</span> comme une somme :</p>
<p><span class="math display">\[
  f = \mathcal{M}_{[f]} + g
\]</span></p>
<p>avec <span class="math inline">\(\mathcal{M}_{[f]}\)</span> est définie par (<a href="#2.8" class="aeq">2.8</a>), et où <span class="math inline">\(g\)</span> est l’écart à l’équilibre maxwellien. Or nous avons :</p>
<p><span class="math display">\[
  \int_{\mathbb{R}^d} m(v)\mathcal{M}_{[f]}\,\mathrm{d}v = \int_{\mathbb{R}^d} m(v)f\,\mathrm{d}v
\]</span></p>
<p>nous pouvons en conclure que <span class="math inline">\(\int m(v)g\,\mathrm{d}v =0\)</span>. Cette décomposition <span class="math inline">\(f = \mathcal{M}_{[f]}+g\)</span> correspond à une décomposition orthogonale de l’espace fonctionnel <span class="math inline">\(L^2_M(\mathbb{R}^d)\)</span> selon le noyau de l’opérateur de collision :</p>
<p><span class="math display">\[
  L_M^2 = \ker Q + \text{Im} Q
\]</span></p>
<p>où l’espace fonctionnel <span class="math inline">\(L^2_M(\mathbb{R}^d)\)</span> est défini par :</p>
<p><span class="math display">\[
  L^2_M = \left\{ f:\mathbb{R}^d\to\mathbb{R} \middle/ \int_{\mathbb{R}^d} \frac{f^2\,\mathrm{d}v}{\mathcal{M}_{[f]}} &lt; +\infty \right\}
\]</span></p>
<p>Cette décomposition peut s’exprimer à l’aide de la projection orthogonale <span class="math inline">\(\Pi\)</span> sur <span class="math inline">\(\ker Q\)</span>, d’où la décomposition de <span class="math inline">\(f\)</span> :</p>
<p><span class="math display">\[
  f = \Pi(f) + (I-\Pi)(f)
\]</span></p>
<p>On a donc <span class="math inline">\(\mathcal{M}_{[f]} = \Pi(f)\)</span> et <span class="math inline">\((I-\Pi)(f) = g\)</span>, où le projecteur <span class="math inline">\(\Pi\)</span> est défini dans <span class="citation" data-cites="BENNOUNE20083781">[1]</span> par :</p>
<p><span class="math display">\[
  \begin{aligned}
    \Pi(\varphi) = \frac{1}{\rho}\left[\vphantom{\frac{\Delta}{\Delta}} \langle \varphi \rangle \right. &amp; + \frac{(v-u)\cdot\langle(v-u)\varphi\rangle}{T} \\
     &amp; + \left. \left( \frac{|v-u|^2}{2T} - \frac{d}{2} \right)\frac{2}{d}\left\langle \left(\frac{|v-u|^2}{2T}-\frac{d}{2}\right)\varphi \right\rangle \right]\mathcal{M}_{[f]}\,\forall \phi ín L_M^2
  \end{aligned}
\]</span><a href="#3.1" id="3.1" class="eq"></a></p>
<p>La projecteur <span class="math inline">\(\Pi\)</span> va nous permettre d’écrire une équation sur les paramètres de <span class="math inline">\(\mathcal{M}_{[f]}\)</span>, à savoir <span class="math inline">\(U\)</span> ou <span class="math inline">\((\rho,u,T)\)</span>, qui représentera le modèle <em>macro</em> ; et une équation sur <span class="math inline">\(g\)</span>, représentant le modèle <em>micro</em>.</p>
<h2 id="obtention-du-modèle-macro">Obtention du modèle <em>macro</em></h2>
<p>Le vecteur <span class="math inline">\(U\)</span> est lié à l’inconnue <span class="math inline">\(f\)</span> via ses moments :</p>
<p><span class="math display">\[
  U = \int_{\mathbb{R}^d} m(v)f(v)\,\mathrm{d}v
\]</span></p>
<p>En introduisant la décomposition <span class="math inline">\(f=\mathcal{M}_{[f]}+g\)</span> et en multipliant le modèle cinétique (<a href="#2.6" class="aeq">2.6</a>) par <span class="math inline">\(m(v)\)</span> puis en intégrant selon <span class="math inline">\(v\)</span> on obtient :</p>
<p><span class="math display">\[
  \partial_t U + \nabla_x\cdot\int_{\mathbb{R}^d}vm(v)(\mathcal{M}_{[f]}+g)\,\mathrm{d}v + \int_{\mathbb{R}^d}E\cdot\nabla_v (\mathcal{M}_{[f]}+g)m(v)\,\mathrm{d}v = 0
\]</span></p>
<p>Le produit <span class="math inline">\(vm(v)\)</span> est une opération triviale en dimension 1 mais se complexifie en dimension <span class="math inline">\(d\)</span> ; celui-ci cache un produit tensoriel :</p>
<p><span class="math display">\[
  v\,m(v) = \begin{pmatrix}v \\ v\otimes v \\ v|v|^2 \end{pmatrix} 
\]</span></p>
<p>où la composante <span class="math inline">\((i,j)\)</span> du produit tensoriel <span class="math inline">\((v\otimes v)\)</span> est donnée par :</p>
<p><span class="math display">\[
  (v\otimes v)_{i,j} = v_i v_k \quad i,j=1,\dots , d
\]</span></p>
<p>Finalement, en notant <span class="math inline">\(\langle \cdot \rangle_v = \int_{\mathbb{R}^d}\cdot\,\mathrm{d}v\)</span> on peut récrire ce modèle :</p>
<p><span class="math display">\[
  \partial_t U + \nabla_x \cdot \langle vm(v)\mathcal{M}_{[f]}\rangle_v + \nabla_v \langle E_fm(v)\mathcal{M}_{[f]}\rangle_v = - \nabla_x\cdot\langle vm(v)g \rangle_v
\]</span></p>
<p>Équation que l’on peut réécrire sous la forme suivante, en utilisant les calculs effectués dans la section <a href="#cinétique-vers-fluide">2.4</a> :</p>
<p><span class="math display">\[
  \partial_t U + \nabla_x\cdot\mathcal{F}(U) +  \nabla_x\langle vm(v)g \rangle_v = -\nabla_v\cdot \langle E_fm(v)\mathcal{M}_{[f]}\rangle_v
\]</span><a href="#3.2" id="3.2" class="eq"></a></p>
<p>L’équation (<a href="#3.2" class="aeq">3.2</a>) correspond à la partie macroscopique du modèle hybride <em>micro-macro</em>.</p>
<blockquote>
<p><strong>Remarque :</strong> On peut remarquer que lorsque <span class="math inline">\(f\to\mathcal{M}_{[f]}\)</span>, cela correspond à <span class="math inline">\(g\to 0\)</span>, et on retrouve les équations d’Euler.</p>
</blockquote>
<h2 id="obtention-du-modèle-micro">Obtention du modèle <em>micro</em></h2>
<p>Pour obtenir la description microscopique, on ne s’intéresse qu’à la perturbation <span class="math inline">\(g\)</span> de <span class="math inline">\(f\)</span>. En effet toute l’information sur l’équilibre maxwellien <span class="math inline">\(\mathcal{M}_{[f]}\)</span> est contenue dans la description macroscopique. Il suffit maintenant de reprendre le modèle cinétique (<a href="#2.6" class="aeq">2.6</a>) et de le projeter sur <span class="math inline">\(\text{Im}Q\)</span>, c’est-à-dire en appliquant le projecteur <span class="math inline">\(I-\Pi\)</span> :</p>
<p><span class="math display">\[
  \partial_t g + (I-\Pi)\left[v\cdot\nabla_x(\mathcal{M}_{[f]}+g) + E_f\cdot\nabla_v(\mathcal{M}_{[f]}+g)\right ] = -\frac{1}{\varepsilon}g
\]</span><a href="#3.3" id="3.3" class="eq"></a></p>
<p>Il s’agit là de la partie microscopique du modèle <em>micro-macro</em>. Pour alléger les notations de la partie <em>micro</em>, nous introduisons l’opérateur de transport <span class="math inline">\(\mathcal{T}_{v,E}\)</span> suivant :</p>
<p><span class="math display">\[
  \mathcal{T}_{v,E} = v\cdot\nabla_x + E\cdot\nabla_v
\]</span></p>
<p>Ainsi nous pouvons écrire le modèle <em>micro-macro</em> complet sous la forme :</p>
<p><span class="math display">\[
  \begin{cases}
    \partial_t U + \nabla_x\cdot\mathcal{F}(U) + \nabla_x\cdot\langle vm(v)g \rangle_v = \begin{pmatrix}0 \\ \rho E \\ \rho uE \end{pmatrix} \\
    \partial_t g + (I-\Pi)[\mathcal{T}_{v,E}(\mathcal{M}_{[f]}+g)] = -\frac{1}{\varepsilon}g
  \end{cases}
\]</span><a href="#3.4" id="3.4" class="eq"></a></p>
<p>où le champ électrique <span class="math inline">\(E\)</span> est calculé de manière similaire à (<a href="#2.5" class="aeq">2.5</a>) :</p>
<p><span class="math display">\[
  \nabla_x\cdot E = \int_{\mathbb{R}^d} \mathcal{M}_{[f]}\,\mathrm{d}v -1
\]</span></p>
<p>Dans <span class="citation" data-cites="BENNOUNE20083781">[1]</span>, il est montré l’équivalence entre le modèle <em>micro-macro</em> (<a href="#3.4" class="aeq">3.4</a>) et le modèle cinétique original (<a href="#2.7" class="aeq">2.7</a>)</p>
<p>Cette réécriture du modèle cinétique sert de base pour des approximations. En effet il sera plus simple dans cette description de négliger la perturbation à l’équilibre <span class="math inline">\(g\)</span> sur une partie du domaine, que l’on nommera partie fluide du domaine.</p>
<blockquote>
<p><strong>Remarque :</strong> Dans le cas limite <span class="math inline">\(\varepsilon \to 0\)</span>, la seconde équation de (<a href="#3.4" class="aeq">3.4</a>) nous donne formellement <span class="math inline">\(g \to 0\)</span>, on retrouve alors l’équation d’Euler dans la première équation. Un développement en puissance de <span class="math inline">\(\varepsilon\)</span> donne :</p>
<p><span class="math display">\[
g = -\varepsilon(I-\Pi)v\cdot\nabla_x\mathcal{M}_{[f]}
\]</span></p>
<p>résultat que l’on peut injecter dans l’équation <em>macro</em> pour obtenir les équations de Navier-Stokes.</p>
</blockquote>
<h2 id="approximation-du-modèle-micro-macro">Approximation du modèle micro-macro</h2>
<p>Dans cette étude, nous nous intéressons à des cas où <span class="math inline">\(f\)</span> est très proche de <span class="math inline">\(\mathcal{M}_{[f]}\)</span> dans certaines régions du domaine, et s’en éloigne dans les autres régions.</p>
<p>L’idée introduite par P. Degond, G. Dimarco et L. Mieussens dans <span class="citation" data-cites="dimarco">[2]</span>, est de coupler le modèle <em>micro</em> (basé sur un modèle cinétique) et le modèle <em>macro</em> (basé sur les équations d’Euler) à l’aide d’une décomposition de domaine <em>adaptative</em>. Cette décomposition va nous permettre de négliger la partie <em>micro</em> dans les régions où le système est proche de son état d’équilibre thermodynamique.</p>
<p>Dans les régions où le système est à l’équilibre, c’est-à-dire <span class="math inline">\(f \approx \mathcal{M}_{[f]}\)</span>, nous allons faire l’approximation <span class="math inline">\(g=0\)</span> dans cette zone. Nous introduisons la fonction <span class="math inline">\(h:\Omega\mapsto[0,1]\)</span> telle que :</p>
<ul>
<li><span class="math inline">\(h = 0\)</span> dans la zone proche de l’équilibre aussi appelée zone fluide, notée <span class="math inline">\(\Omega_F\)</span>.</li>
<li><span class="math inline">\(h=1\)</span> dans la zone hors équilibre aussi appelée zone cinétique, notée <span class="math inline">\(\Omega_K\)</span>.</li>
</ul>
<p><span class="math display">\[
  \Omega = \Omega_F \cup \Omega_K
\]</span></p>
<blockquote>
<p>TODO: tracer un truc ressemblant à <span class="math inline">\(h(x)\)</span></p>
</blockquote>
<p>Utiliser une fonction indicatrice <span class="math inline">\(h\)</span> continument dérivable permet d’éviter une rupture de modèle et de ne pas avoir à introduire des conditions aux bords entre le modèle fluide et cinétique ; comme les approches de décomposition de domaine classiques qui nécessitent des conditions aux bords pour connecter les différents modèles, ainsi qu’une gestion difficile entre l’interface fluide et cinétique en plusieurs dimensions. Nous obtenons donc une zone de transition des modèles où la solution calculée est une superposition des deux solutions, pondérée par la valeur de <span class="math inline">\(h\)</span>. Nous allons pouvoir définir :</p>
<p><span class="math display">\[
  g = hg + (1-h)g = g_K + g_F
\]</span></p>
<p>où <span class="math inline">\(g_K=hg\)</span> correspond à la perturbation par rapport à l’équilibre maxwellien dans <span class="math inline">\(\Omega_K\)</span>, et <span class="math inline">\(g_F = (1-h)g\)</span> dans <span class="math inline">\(\Omega_F\)</span>. Dans <span class="math inline">\(\Omega_F\)</span> on suppose que le système est proche de l’équilibre <span class="math inline">\(f \approx \mathcal{M}_{[f]}\)</span>, par conséquent la grandeur <span class="math inline">\(g_F\)</span> pourra être négligée.</p>
<p>Tentons d’exploiter cette hypothèse dans le modèle <em>micro-macro</em> (<a href="#3.4" class="aeq">3.4</a>), reprenons le modèle <em>micro</em> que nous multiplions par <span class="math inline">\(h\)</span> :</p>
<p><span class="math display">\[
  \underbrace{h\partial_t g}_{(1)} + \underbrace{h(I-\Pi)(\mathcal{T}_{v,E}\mathcal{M}_{[f]})}_{(2)} + \underbrace{h(I-\Pi)(\mathcal{T}_{v,E}(g_K+g_F))}_{(3)} = -\frac{h}{\varepsilon}g
\]</span></p>
<ol type="1">
<li>Or <span class="math inline">\(\partial_t g_k = \partial_t(hg) = h\partial_t g - g\partial_t h\)</span> ; donc <span class="math inline">\(h\partial_t g = \partial_t g_K - g\partial_t h\)</span> ;</li>
<li>Le second terme ne dépend par de <span class="math inline">\(g\)</span>, on le passe donc dans le membre de droite.</li>
<li>On distingue ce terme en deux parties, entre l’opérateur identité et le projecteur <span class="math inline">\(\Pi\)</span>, ce second terme ira dans le membre de droite.</li>
</ol>
<p>D’où :</p>
<p><span class="math display">\[
  \begin{aligned}
    \partial_t g_K + h\mathcal{T}_{v,E}(g_K) + h\mathcal{T}_{v,E}(g_F) &amp;= \\
     -\frac{1}{\varepsilon}g_K + \frac{g_K}{h}\partial_t h - h(I-\Pi)&amp;(\mathcal{T}_{v,E}\mathcal{M}_{[f]}) + h\Pi(\mathcal{T}_{v,E}(g_K+g_F))
  \end{aligned}
\]</span><a href="#3.5" id="3.5" class="eq"></a></p>
<p>P. Degond, G. Dimarco et L. Mieussens proposent dans <span class="citation" data-cites="dimarco">[2]</span> une simplification du terme <span class="math inline">\(- h(I-\Pi)(\mathcal{T}_{v,E}\mathcal{M}_{[f]}) + h\Pi(\mathcal{T}_{v,E}(g_K+g_F))\)</span> pour ne l’exprimer qu’en fonction de la distribution maxwellienne <span class="math inline">\(\mathcal{M}_{[f]}\)</span>. Pour cela il est nécessaire de reprendre le modèle <em>macro</em> (<a href="#3.2" class="aeq">3.2</a>), qui en décomposant <span class="math inline">\(f=\mathcal{M}_{[f]} + g\)</span> permet d’exprimer <span class="math inline">\(\partial_t\mathcal{M}_{[f]}\)</span> :</p>
<p><span class="math display">\[
  \partial_t\mathcal{M}_{[f]} = - \partial_t g - \frac{1}{\varepsilon}g - \mathcal{T}_{v,E}(\mathcal{M}_{[f]}+g)
\]</span></p>
<p>Le modèle <em>micro</em> (<a href="#3.3" class="aeq">3.3</a>) quant à lui nous donne une expression pour <span class="math inline">\(\partial_t g\)</span> :</p>
<p><span class="math display">\[
  -\partial_t g = \frac{1}{\varepsilon}g +(I-\Pi)(\mathcal{T}_{v,E}(\mathcal{M}_{[f]}+g))
\]</span></p>
<p>Ainsi <span class="math inline">\(\partial_t\mathcal{M}_{[f]}\)</span> peut s’exprimer comme suit :</p>
<p><span class="math display">\[
  \partial_t\mathcal{M}_{[f]} = -\Pi(\mathcal{T}_{v,E}(\mathcal{M}_{[f]}+g_K+g_F))
\]</span></p>
<p>Il devient alors possible de simplifier le dernier terme de (<a href="#3.5" class="aeq">3.5</a>), ce qui mène à la réécriture suivante :</p>
<p><span class="math display">\[ 
  \partial_t g_K + h\mathcal{T}_{v,E}(g_K) + h\mathcal{T}_{v,E}(g_F) = -\frac{1}{\varepsilon}g_K + \frac{g_K}{h}\partial_t h - h(\partial_t+\mathcal{T}_{v,E})\mathcal{M}_{[f]}
\]</span></p>
<p>Cette formulation permet de ne conserver aucune projection de <span class="math inline">\(g_F\)</span> ou <span class="math inline">\(g_K\)</span>. Il devient donc plus aisé de travailler sur ces grandeurs que nous souhaitons approximer, mais implique numériquement le calcul de l’approximation de <span class="math inline">\(\partial_t \mathcal{M}_{[f]}\)</span> qui est une opération potentiellement coûteuse aussi bien en temps de calcul qu’en utilisation mémoire, ainsi dans la partie numérique la formulation conservant les projections de <span class="math inline">\(g_K\)</span> sera préférée.</p>
<p>Nous effectuons une approximation par rapport à <span class="math inline">\(g\)</span>, en effet la fonction indicatrice <span class="math inline">\(h\)</span> permet de subdiviser le domaine. Nous négligerons <span class="math inline">\(g_F\)</span> par la suite :</p>
<p><span class="math display">\[
  g_F = 0
\]</span></p>
<p>La partie <em>micro</em> du modèle <em>micro-macro</em>, après cette approximation devient :</p>
<p><span class="math display">\[
  \partial_t g_K + h\mathcal{T}_{v,E}(g_K) = -\frac{1}{\varepsilon}g_K - h(I-\Pi)(\mathcal{T}_{v,E} \mathcal{M}_{[f]}) + h\Pi(\mathcal{T}_{v,E}(g_K)) + \frac{g_K}{h}\partial_t h
\]</span><a href="#3.6" id="3.6" class="eq"></a></p>
<h1 id="présentation-des-schémas">Présentation des schémas</h1>
<p>On se limitera dans cette partie à l’étude du problème unidimensionnel : <span class="math inline">\(d=1\)</span>.</p>
<p>Dans cette partie, nous allons présenter différents schémas numériques pour résoudre le modèle <em>micro-macro</em> (<a href="#3.4" class="aeq">3.4</a>) et sa version approximé (<a href="#3.6" class="aeq">3.6</a>). Ce modèle comporte plusieurs difficultés qui devront être surmontées :</p>
<ul>
<li>Nous allons chercher des schémas d’ordre élevé en <span class="math inline">\((x,v)\)</span> pour capturer les forts gradients qui peuvent apparaître selon les conditions initiales. Ces schémas dans l’espace des phases devront aussi fonctionner en multi-dimensions.</li>
<li>L’opérateur de collision apporte un terme de raideur en <span class="math inline">\(\frac{1}{\varepsilon}\)</span> quand <span class="math inline">\(\varepsilon \to 0\)</span>, qui va nécessiter des intégrateurs en temps particuliers.</li>
<li>Il est bien évidemment nécessaire d’assurer la stabilité du schéma par rapport au terme de transport, les simulations de plasma se faisant souvent en temps long.</li>
</ul>
<h2 id="schémas-en-temps">Schémas en temps</h2>
<p>Pour étudier la raideur en <span class="math inline">\(\frac{1}{\varepsilon}\)</span>, on se propose d’étudier la dynamique temporelle de l’équation différentielle suivante qui contient les mêmes difficultées mais est simplifiée par rapport au modèle <em>micro-macro</em> complet :</p>
<p><span class="math display">\[
  \begin{cases}
    \frac{\mathrm{d}u}{\mathrm{d}t}(t) = -\frac{1}{\varepsilon}u(t) + \mathcal{F}(u(t)) \\
    u(0) = u_0
  \end{cases}
\]</span><a href="#4.1" id="4.1" class="eq"></a></p>
<p>avec <span class="math inline">\(t\)</span> représentant le temps, <span class="math inline">\(u:\mathbb{R}_+\!\to\mathbb{R}\)</span> la fonction inconnue, <span class="math inline">\(\mathcal{F}:\mathbb{R}\to\mathbb{R}\)</span> une fonction donnée régulière, avec comme condition initiale <span class="math inline">\(u_0\in\mathbb{R}\)</span>.</p>
<p>On peut résumer la difficulté au cas <span class="math inline">\(\mathcal{F} = 0\)</span> pour étudier la stabilité des schémas temporels, au détriment de quelques paramètres physiques :</p>
<p><span class="math display">\[
  \frac{\mathrm{d}u}{\mathrm{d}t} = -\frac{1}{\varepsilon}u
\]</span><a href="#4.2" id="4.2" class="eq"></a></p>
<p>où <span class="math inline">\(\varepsilon &gt; 0\)</span> peut être aussi petit que l’on veut. L’enjeu est de construire un schéma temporel uniformément stable par rapport à <span class="math inline">\(\varepsilon \in ]0,1]\)</span>.</p>
<p>Une discrétisation en temps de (<a href="#4.2" class="aeq">4.2</a>) nous amènera à calculer une approximation <span class="math inline">\(u^n \approx u(t^n)\)</span>, <span class="math inline">\(n\in\mathbb{N}\)</span> où <span class="math inline">\(t^n = n\Delta t\)</span> avec <span class="math inline">\(\Delta t\)</span> notre pas de temps. Ainsi la discrétisation via un schéma d’Euler explicite de (<a href="#4.2" class="aeq">4.2</a>) nous donne :</p>
<p><span class="math display">\[
  \frac{u^{n+1}-u^n}{\Delta t} = -\frac{1}{\varepsilon}u^n
\]</span></p>
<p>soit :</p>
<p><span class="math display">\[
  u^n = \left( 1-\frac{\Delta t}{\varepsilon}\right)^n u_0
\]</span></p>
<p>La solution <span class="math inline">\((u^n)_n\)</span> reste bornée si et seulement si <span class="math inline">\(| 1-\frac{\Delta t}{\varepsilon} |\leq 1\)</span>, <em>ie</em> <span class="math inline">\(\Delta t \leq 2\varepsilon\)</span>. Or le paramètre <span class="math inline">\(\varepsilon\)</span> peut être choisi arbitrairement petit, donc cette condition est très contraignante et conduit à des temps de calculs trop coûteux. Il est donc impératif d’utiliser un schéma d’Euler implicite de la forme :</p>
<p><span class="math display">\[
  \frac{u^{n+1}-u^n}{\Delta t} = -\frac{1}{\varepsilon}u^{n+1}
\]</span></p>
<p>soit, sous forme itérative :</p>
<p><span class="math display">\[
  u^n = \frac{1}{(1+\frac{\Delta t}{\varepsilon})^n}u_0
\]</span></p>
<p>ce qui est inconditionnellement stable quelle que soit la valeur de <span class="math inline">\(\Delta t\)</span> et de <span class="math inline">\(\varepsilon\)</span>. En outre, lorsque <span class="math inline">\(\varepsilon\to 0\)</span> et <span class="math inline">\(\Delta t\to 0\)</span> fixé :</p>
<p><span class="math display">\[
  u^n \overset{\varepsilon\to 0}{\to} 0
\]</span></p>
<p>comme la solution exacte <span class="math inline">\(u(t) = u_0 \exp\left(-\frac{t}{\varepsilon}\right)\)</span>. On dit alors que le schéma est <em>asymptotic preserving</em>. Par conséquent nous utiliserons un schéma d’Euler implicite en temps pour tester et valider nos différents schémas sur le terme de transport.</p>
<h3 id="schéma-runge-kutta-dordre-3">Schéma Runge-Kutta d’ordre 3</h3>
<blockquote>
<p>TODO: mettre le numéro de la section dans <em>“que l’on détaillera plus tard”</em></p>
</blockquote>
<p>Pour des raisons de stabilité, liées à l’utilisation de schémas d’ordre élevé en <span class="math inline">\(x\)</span> (que l’on détaillera plus tard), nous avons été amené à considérer le schéma de Runge-Kutta d’ordre 3 (RK3).</p>
<p>Le schéma en temps se résout de manière indépendante du schéma d’advection, par conséquent il s’agit d’une simple équation différentielle ordinaire que nous écrirons :</p>
<p><span class="math display">\[
  \frac{\mathrm{d}u}{\mathrm{d}t}(t) = L(u(t),t)
\]</span><a href="#4.3" id="4.3" class="eq"></a></p>
<p>avec <span class="math inline">\(t\)</span> le temps, <span class="math inline">\(u:\mathbb{R}_+\to\mathbb{R}\)</span> la fonction inconnue, <span class="math inline">\(L:\mathbb{R}\times\mathbb{R}_+\to\mathbb{R}\)</span> une fonction dépendant de <span class="math inline">\(u\)</span> et du temps. Nous cherchons à calculer <span class="math inline">\(u^n \approx u(t^n)\)</span>, une approximation de <span class="math inline">\(u\)</span> au temps <span class="math inline">\(t^n = n\Delta t\)</span>, avec <span class="math inline">\(\Delta t &gt; 0\)</span> le pas de temps. Il existe plusieurs formulations du schéma de Runge-Kutta d’ordre 3. L’ordre 3 nécessite au minimum 3 étapes de calculs, une version ajoutant de la stabilité en 4 étapes existe, ainsi qu’une version utilisant peu de mémoire, décrie dans <span class="citation" data-cites="ssp_rk3">[5]</span>. Nous utiliserons le schéma suivant, le plus rapide en temps de calcul :</p>
<p><span class="math display">\[
  \begin{aligned}
    u^{(1)} &amp;= u^n + \Delta t L(u^n,t^n) \\
    u^{(2)} &amp;= \frac{3}{4}u^n + \frac{1}{4}u^{(1)} + \frac{1}{4}\Delta t L(u^{(1)},t^n+\Delta t) \\
    u^{n+1} &amp;= \frac{1}{3}u^n + \frac{2}{3}u^{(2)} + \frac{2}{3}\Delta t L(u^{(2)},t^n+\frac{1}{2}\Delta t)
  \end{aligned}
\]</span></p>
<p>Dans le cadre du modèle <em>micro-macro</em> par exemple, nous avons <span class="math inline">\(u=g\)</span> dans la partie <em>micro</em> sans terme de collision, <span class="math inline">\(L\)</span> désignant les termes de transport et les termes sourrce.</p>
<p>Si la simulation se concentre sur un plasma peu dense, c’est-à-dire <span class="math inline">\(\varepsilon\to\infty\)</span>, le terme raide dans la partie <em>micro</em> du modèle <em>micro-macro</em> (<a href="#3.4" class="aeq">3.4</a>) peut s’approximer par :</p>
<p><span class="math display">\[
  \partial_t g + (I-\Pi)[\mathcal{T}_{v,E}(\mathcal{M}_{[f]}+g)] = 0
\]</span></p>
<p>Dans ce cas, nous utilisons (<a href="#4.3" class="aeq">4.3</a>) avec <span class="math inline">\(u = g\)</span> et <span class="math inline">\(L(u) = -(I-\Pi)[\mathcal{T}_{v,E}(\mathcal{M}_{[f]}+g]\)</span>. Pour les autres valeurs de <span class="math inline">\(\varepsilon\)</span> il est nécessaire d’effectuer une reformulation de la partie <em>micro</em> pour exploiter ce schéma temporel.</p>
<h2 id="schémas-dadvection-dordre-élevé">Schémas d’advection d’ordre élevé</h2>
<p>Pour approcher le terme de transport <span class="math inline">\(\partial_t g + \mathcal{T}_{v,E}(g)\)</span> de (<a href="#3.3" class="aeq">3.3</a>), il est primordial d’utiliser des schémas d’ordre élevé pour :</p>
<ul>
<li>Capturer les forts gradients en diminuant la viscosité numérique ;</li>
<li>Utiliser moins de points lors de la simulation.</li>
</ul>
<p>Pour ces raisons nous allons présenter deux schémas d’ordre élevé permettant de résoudre une part de ces problèmes.</p>
<p>Nous étudirons ces schémas tout d’abord en l’absence de champ électrique <span class="math inline">\(E\)</span>. Le transport selon <span class="math inline">\(x\)</span> et <span class="math inline">\(v\)</span> étant indépendant ils peuvent être étudié séparément. Nous nous ramenons donc à des cas de transport 1D selon <span class="math inline">\(x\)</span>. Le transport de <span class="math inline">\(g\)</span> donné par :</p>
<p><span class="math display">\[
  \partial_t g + v\partial_x g = 0
\]</span></p>
<p>se ramène à une équation d’advection linéaire lorsque <span class="math inline">\(v\)</span> est discrétisé par <span class="math inline">\(v_k = k\Delta v\)</span> avec <span class="math inline">\(k\in [\![ -K ,K ]\!]\)</span>, <span class="math inline">\(K\in\mathbb{N}\)</span> et <span class="math inline">\(\Delta v &gt; 0\)</span> le pas de vitesse dans l’espace des phases. Ainsi l’exemple de base que nous utiliserons pour présenter ces schémas est une équation d’advection linéaire en une dimension :</p>
<p><span class="math display">\[
  \begin{cases}
    \partial_t u + a \partial_x u = 0 \\
    u(t=0,x) = u^0(x)
  \end{cases}
\]</span><a href="#4.4" id="4.4" class="eq"></a></p>
<p>où <span class="math inline">\(t\)</span> est le temps, <span class="math inline">\(x\)</span> la dimension d’espace, <span class="math inline">\(u : \mathbb{R}_+\times\mathbb{R}\to\mathbb{R}\)</span> est la fonction inconnue et la vitesse <span class="math inline">\(a\in\mathbb{R}\)</span>. On ajoute à cette équation des conditions aux bords qui dépendront des cas tests présentés.</p>
<p>Nous cherchons à calculer <span class="math inline">\(u^n_i \approx u(t^n,x_i)\)</span> une approximation de <span class="math inline">\(u\)</span> au temps <span class="math inline">\(t^n = n\Delta t\)</span>, avec <span class="math inline">\(\Delta t&gt;0\)</span> le pas de temps, en <span class="math inline">\(x_i = i\Delta x\)</span>, avec <span class="math inline">\(\Delta x&gt;0\)</span> le pas d’espace.</p>
<h3 id="schéma-compact">Schéma compact</h3>
<p>Dans un premier temps nous présenterons uniquement le cas d’un transport à vitesse <span class="math inline">\(a\)</span> constante positive. Un schéma linéaire différences finies avec un <em>stencil</em> de taille <span class="math inline">\(r+s+1\)</span> (<span class="math inline">\(r,s\in\mathbb{N}\)</span>) peut s’écrire de manière générale comme :</p>
<p><span class="math display">\[
  u_i^{n+1} = \sum_{k=-r}^s \gamma_k u_{i+k}^n
\]</span><a href="#4.5" id="4.5" class="eq"></a></p>
<p>où <span class="math inline">\(\gamma_k\in\mathbb{R}\)</span> est un coefficient dépendant du nombre CFL <span class="math inline">\(\nu = a\frac{\Delta t}{\Delta x}\)</span>.</p>
<p>On peut réécrire (<a href="#4.5" class="aeq">4.5</a>) en forumulation volumes finis :</p>
<p><span class="math display">\[
  u_i^{n+1} = u_i^n - \nu (u^n_{i+\frac{1}{2}} - u^n_{i-\frac{1}{2}})
\]</span></p>
<p>où <span class="math inline">\(u^n_{i+\frac{1}{2}}\)</span> sont les flux numériques. Le calcul de ces flux est présenté dans <span class="citation" data-cites="Boyer:2014aa">[6]</span> pour différents ordres. Nous choisirons ceux d’ordre élevé décrits dans <span class="citation" data-cites="despres">[7]</span>. L’ordre du flux dépend du choix du couple <span class="math inline">\((r,s)\)</span>, il est ainsi possible de retrouver plusieurs flux connus :</p>
<ul>
<li><p>Le schéma décentré amont, ou <em>upwind</em> :</p>
<p><span class="math display">\[
  u_{i+\frac{1}{2}}^n = u_i^n
\]</span></p></li>
<li><p>Une combinaison de <em>Lax-Wendroff</em> (LW) et de <em>Beam-Warming</em> (BW) : <span class="math inline">\((1-\alpha )LW + \alpha BW\)</span> avec <span class="math inline">\(\alpha = \frac{1+\nu}{3}\)</span> :</p>
<p><span class="math display">\[
  u_{i+\frac{1}{2}}^n = u_i^n + \frac{2-\nu}{6}(1-\nu)(u_{i+1}^n-u_{i}^n) + \frac{1+\nu}{6}(1-\nu)(u_i^n-u_{i-1}^n)
\]</span></p></li>
<li><p>Dans <span class="citation" data-cites="despres">[7]</span>, B. Després propose le schéma à 6 points d’ordre 5 suivant :</p>
<p><span class="math display">\[
  \begin{aligned}
    u_{i+\frac{1}{2}}^n = &amp; \ u_{i+2}^n + \frac{\nu+3}{2}(u_{i+1}^n-u_{i+2}^n) + \frac{(2+\nu)(1+\nu)}{6}(u_i^n - 2u_{i+1}^n + u_{i+2}^n) \\
                        &amp; + \frac{(2+\nu)(1+\nu)(\nu-1)}{24}(u_{i-1}^n - 3u_{i}^n + 3u_{i+1}^n - u_{i+2}^n) \\
                        &amp; + \frac{(2+\nu)(1+\nu)(\nu-1)(\nu-2)}{120}(u_{i-2}^n - 4u_{i-1}^n + 6u_{i}^n - 4u_{i+1}^n + u_{i+2}^n)
  \end{aligned}
\]</span></p></li>
</ul>
<p>C’est ce dernier flux que nous utiliserons par la suite.</p>
<p>L’utilisation d’une vitesse <span class="math inline">\(a\)</span> quelconque s’effectue en suivant le <em>sens du vent</em>, c’est-à-dire, en notant :</p>
<ul>
<li><span class="math inline">\(a^+ = \max(a,0)\)</span>,</li>
<li><span class="math inline">\(a^- = \min(a,0)\)</span>,</li>
</ul>
<p>on obtient alors le schéma pour toute vitesse suivant :</p>
<p><span class="math display">\[
  u^{n+1}_i = u^n_i - a^+\frac{\Delta t}{\Delta x}(u^n_{i+\frac{1}{2}} - u^n_{i-\frac{1}{2}}) - a^-\frac{\Delta t}{\Delta x}(u^n_{i+\frac{3}{2}}-u^n_{i+\frac{1}{2}})
\]</span></p>
<h4 id="obtention-de-lordre-en-espace">Obtention de l’ordre en espace</h4>
<p>La solution exacte d’un problème de transport à vitesse <span class="math inline">\(a\)</span> constante est connue. Nous allons donc partir de ce problème, le résoudre sur un premier maillage et en calculer l’erreur ; puis répéter l’opération sur un maillage plus fin. Les différentes résolutions sur différents maillages s’effectuent toutes jusqu’au même temps final.</p>
<p>Le problème que nous considérons est (<a href="#4.4" class="aeq">4.4</a>) avec <span class="math inline">\(a=1\)</span> :</p>
<p><span class="math display">\[
  \partial_t u + \partial_x u = 0 \quad, u(t=0,x) = u_0(x)
\]</span></p>
<p>L’équation est considérée pour <span class="math inline">\(x\in[0,2\pi]\)</span>, avec des conditions aux bords périodiques ; et nous allons considérer un cosinus comme condition initiale :</p>
<p><span class="math display">\[
  u_i^0 = \cos(x_i)
\]</span></p>
<p>avec <span class="math inline">\(x_i = i\Delta x\)</span> et le pas d’espace <span class="math inline">\(\Delta x = \frac{2\pi}{N}\)</span>, où <span class="math inline">\(N\)</span> est le nombre de points du maillage. La solution exacte au temps <span class="math inline">\(t^n= n\Delta t\)</span>, <span class="math inline">\(n\in\mathbb{N}\)</span>, <span class="math inline">\(\Delta t &gt;0\)</span> est :</p>
<p><span class="math display">\[
  u(t^n,x_i) = \cos(x_i - t^n)
\]</span></p>
<h5 id="calcul-à-pas-de-temps-fixe">Calcul à pas de temps fixe</h5>
<p>Pour être certain de ne pas prendre en compte l’erreur en temps dans le calcul de l’erreur en espace, il est possible de résoudre le problème sur un seul pas de temps toujours identique. Ainsi le seul paramètre modifié d’une simulation à l’autre est le raffinage du maillage et on observera uniquement l’erreur en espace.</p>
<p>Un seul pas de temps suffit pour l’obtention de l’ordre :</p>
<p><span class="math display">\[
  u_i^1 = u_i^0 - \frac{\Delta t}{\Delta x}( u^0_{i+\frac{1}{2}} - u^0_{i-\frac{1}{2}}) = \cos(x_i - \Delta t) + \mathcal{O}(\Delta x^m)
\]</span></p>
<p>où <span class="math inline">\(m\)</span> est l’ordre recherché. L’erreur se calcule par la norme de la différence de la solution approchée avec la solution exacte. Plus précisément, elle est définie par :</p>
<p><span class="math display">\[
  e_1 = \sum_{i=1}^N |u_i^1 - \cos(x_i - \Delta t) |\Delta x
\]</span></p>
<p>en norme <span class="math inline">\(L^1\)</span>, ou</p>
<p><span class="math display">\[
  e_{\infty} =  \sup_{i=1,\dots,N} |u_i^1 - \cos(x_i - \Delta t) |
\]</span></p>
<p>en norme infinie.</p>
<p>Par définition, un schéma d’ordre <span class="math inline">\(m\)</span> est tel que <span class="math inline">\(e_1 = C\Delta x^m\)</span> ou <span class="math inline">\(e_{\infty} = \tilde{C}\Delta x^m\)</span>, donc en traçant l’erreur sur une échelle logarithmique on trouve :</p>
<p><span class="math display">\[
  \log e_1 = \log C + m \log \Delta x
\]</span></p>
<p>En effectuant cette simulation pour différentes valeurs de <span class="math inline">\(\Delta x\)</span> on peut tracer <span class="math inline">\(\log e_1 = F(\log \Delta x)\)</span>, où l’on doit obtenir une droite dont la pente indique l’ordre.</p>
<p>Dans notre cas nous prendrons <span class="math inline">\(\Delta x = \frac{2\pi}{m}\)</span> avec différentes valeurs de <span class="math inline">\(m\)</span> entre <span class="math inline">\(10\)</span> et <span class="math inline">\(200\)</span>. Pour assurer notre condition CFL nous choisirons <span class="math inline">\(\Delta t &lt; \frac{2\pi}{200}\)</span> fixé.</p>
<figure>
<img src="img/ordre_compact_onestep.png" alt="Mesure de l’ordre sur un seul pas de temps" /><figcaption>Mesure de l’ordre sur un seul pas de temps</figcaption>
</figure>
<p>La figure (TODO référence de la figure) montre l’erreur en fonction du pas d’espace <span class="math inline">\(\Delta x\)</span> en échelle logarithmique. L’erreur est calculée sur un seul pas de temps <span class="math inline">\(\Delta t = \pi 10^{-6}\)</span>. On y mesure, quelque soit la méthode de calcul de l’erreur (erreur en norme 1 : <span class="math inline">\(e_1\)</span> ou erreur en norme infini : <span class="math inline">\(e_\infty\)</span>) l’ordre à une valeur environ de <span class="math inline">\(5\)</span> (pente en pointillée). Ceci est confirmé par les valeurs numériques données dans le tableau ci-dessous. L’ordre partiel <span class="math inline">\(p\)</span>, calculé par :</p>
<p><span class="math display">\[
  p = \frac{\log((e_1^1)_i)-\log((e_1^1)_{i-1})}{\Delta x_i - \Delta x_{i-1}}
\]</span></p>
<p>et permet d’estimer avec les points précédent la valeur de l’ordre. L’ordre partiel calculé à partir de l’erreur infini donne le même ordre de grandeur. On trouve aussi par cette méthode une valeur proche de <span class="math inline">\(5\)</span>.</p>
<table>
<caption>Erreur et ordre sur un seul pas de temps <span class="math inline">\(\Delta t = \pi 10^{-6}\)</span></caption>
<colgroup>
<col style="width: 4%" />
<col style="width: 26%" />
<col style="width: 24%" />
<col style="width: 26%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr class="header">
<th>m</th>
<th><span class="math inline">\(\log(\Delta x)\)</span></th>
<th><span class="math inline">\(\log(\Delta e_1)\)</span></th>
<th><span class="math inline">\(\log(\Delta e_{\infty})\)</span></th>
<th>Ordre partiel</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>10</td>
<td>0.62831853071795862</td>
<td>1.8885115323892025E-008</td>
<td>4.6439991852054163E-009</td>
<td>—</td>
</tr>
<tr class="even">
<td>20</td>
<td>0.31415926535897931</td>
<td>6.3343666063889316E-010</td>
<td>1.5632262151399345E-010</td>
<td>4.89790541666598</td>
</tr>
<tr class="odd">
<td>30</td>
<td>0.20943951023931953</td>
<td>8.3633337412339448E-011</td>
<td>2.0870083439206155E-011</td>
<td>4.99356851573894</td>
</tr>
<tr class="even">
<td>40</td>
<td>0.15707963267948966</td>
<td>1.9970045946399870E-011</td>
<td>4.9763526632773392E-012</td>
<td>4.9784428799281</td>
</tr>
<tr class="odd">
<td>50</td>
<td>0.12566370614359174</td>
<td>6.5414345863822243E-012</td>
<td>1.6342482922482304E-012</td>
<td>5.00160970143643</td>
</tr>
<tr class="even">
<td>60</td>
<td>0.10471975511965977</td>
<td>2.6340730808331303E-012</td>
<td>6.5758509748548022E-013</td>
<td>4.98912561409769</td>
</tr>
<tr class="odd">
<td>70</td>
<td>8.9759790102565518E-002</td>
<td>1.2182339893132100E-012</td>
<td>3.0442315335221792E-013</td>
<td>5.00243715241308</td>
</tr>
<tr class="even">
<td>80</td>
<td>7.8539816339744828E-002</td>
<td>6.2539805846059710E-013</td>
<td>1.5620837956475953E-013</td>
<td>4.9933516428147</td>
</tr>
<tr class="odd">
<td>90</td>
<td>6.9813170079773182E-002</td>
<td>3.4700222375271565E-013</td>
<td>8.6708418223224726E-014</td>
<td>5.00120538432754</td>
</tr>
<tr class="even">
<td>100</td>
<td>6.2831853071795868E-002</td>
<td>2.0498639824922264E-013</td>
<td>5.1181281435219717E-014</td>
<td>4.99606098371577</td>
</tr>
<tr class="odd">
<td>110</td>
<td>5.7119866428905326E-002</td>
<td>1.2722515599787320E-013</td>
<td>3.1863400806741993E-014</td>
<td>5.00455700829749</td>
</tr>
<tr class="even">
<td>120</td>
<td>5.2359877559829883E-002</td>
<td>8.2310995826784676E-014</td>
<td>2.0650148258027912E-014</td>
<td>5.00456041835972</td>
</tr>
<tr class="odd">
<td>130</td>
<td>4.8332194670612200E-002</td>
<td>5.5237440477356868E-014</td>
<td>1.3877787807814457E-014</td>
<td>4.98313617961912</td>
</tr>
<tr class="even">
<td>140</td>
<td>4.4879895051282759E-002</td>
<td>3.8176960539761382E-014</td>
<td>9.5479180117763462E-015</td>
<td>4.98473748123279</td>
</tr>
<tr class="odd">
<td>150</td>
<td>4.1887902047863905E-002</td>
<td>2.6943202835700349E-014</td>
<td>6.7723604502134549E-015</td>
<td>5.05126322851504</td>
</tr>
<tr class="even">
<td>160</td>
<td>3.9269908169872414E-002</td>
<td>1.9561511738522877E-014</td>
<td>4.9960036108132044E-015</td>
<td>4.96086828681551</td>
</tr>
<tr class="odd">
<td>170</td>
<td>3.6959913571644624E-002</td>
<td>1.4410539036993013E-014</td>
<td>3.6637359812630166E-015</td>
<td>5.04092435136205</td>
</tr>
<tr class="even">
<td>180</td>
<td>3.4906585039886591E-002</td>
<td>1.0858427052693538E-014</td>
<td>2.7755575615628914E-015</td>
<td>4.95147314350128</td>
</tr>
<tr class="odd">
<td>190</td>
<td>3.3069396353576773E-002</td>
<td>8.2733617562961384E-015</td>
<td>2.1094237467877974E-015</td>
<td>5.02893495215468</td>
</tr>
<tr class="even">
<td>200</td>
<td>3.1415926535897934E-002</td>
<td>6.3763847861952675E-015</td>
<td>1.6653345369377348E-015</td>
<td>5.07745975149194</td>
</tr>
</tbody>
</table>
<h5 id="calcul-à-nombre-de-cfl-constant">Calcul à nombre de CFL constant</h5>
<p>Il est intéressant de faire une simulation sur plusieurs pas de temps pour amplifier la visibilité de l’ordre du schéma ; l’inconvénient est que l’erreur du schéma temporel, empêche d’observer l’erreur due au schéma spatial sans choisir un pas de temps arbitrairement très faible. Pour remédier en partie à ce problème nous allons travailler sur un nombre de CFL constant, c’est-à-dire :</p>
<p><span class="math display">\[
  \frac{\Delta t}{\Delta x} = c
\]</span></p>
<p>Ainsi à chaque raffinement de maillage, le pas de temps est aussi raffiné, l’erreur en temps diminue donc de manière similaire.</p>
<figure>
<img src="img/ordre_compact.png" alt="Mesure de l’ordre sur plusieurs itérations" /><figcaption>Mesure de l’ordre sur plusieurs itérations</figcaption>
</figure>
<p>La figure (TODO référence de la figure) montre l’évolution de l’erreur en fonction du pas d’espace <span class="math inline">\(\Delta x\)</span> en échelle logarithmique. L’erreur est indiquée pour 2 temps distincts <span class="math inline">\(t_1= 0.1\)</span> et <span class="math inline">\(t_2 = 1\)</span> pour un nombre de CFL égal à <span class="math inline">\(c = 10^{-4}\)</span>. L’erreur infinie, au temps <span class="math inline">\(t_i\)</span>, notée <span class="math inline">\(e_\infty^{i}\)</span> est systématiquement plus faible que l’erreur en norme 1, notée <span class="math inline">\(e_1^{i}\)</span>, car cette dernière dénote un caractère plus global (somme des erreurs locales). L’écart entre les erreurs au temps <span class="math inline">\(t_1\)</span> et au temps <span class="math inline">\(t_2\)</span> illustre l’erreur du schéma en temps, ici un schéma d’Euler explicite. Les points pour un <span class="math inline">\(\Delta x\)</span> faible, donc à droite de la figure ne permettent pas de calculer convenablement l’ordre du schéma puisqu’il s’agit d’une propriété à la limite quand <span class="math inline">\(\Delta x \to 0\)</span>. Ainsi l’ordre mesuré sur la figure à l’aide d’une minimisation (valeur de <span class="math inline">\(4.48\)</span>) est faussée par la présence des ces points. Le tableau suivant (TODO référence du tableau) permet de se donner une idée de l’ordre partiel et ainsi de la valeur limite pour de faibles valeurs de <span class="math inline">\(\Delta x\)</span>. On peut donc affirmer que l’ordre de ce schéma est 5, ce qui est en accord avec le résultat obtenu dans <span class="citation" data-cites="siam2013">[8]</span>.</p>
<table>
<caption>Erreur et ordre au temps <span class="math inline">\(t_1 = 0.1\)</span> et au temps <span class="math inline">\(t_2 = 1\)</span></caption>
<colgroup>
<col style="width: 5%" />
<col style="width: 12%" />
<col style="width: 8%" />
<col style="width: 12%" />
<col style="width: 13%" />
<col style="width: 7%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 12%" />
</colgroup>
<thead>
<tr class="header">
<th><span class="math inline">\(m\)</span></th>
<th><span class="math inline">\(\Delta x\)</span></th>
<th><span class="math inline">\(n^1\)</span></th>
<th><span class="math inline">\(e_1^1\)</span></th>
<th><span class="math inline">\(e_\infty^1\)</span></th>
<th><span class="math inline">\(n^2\)</span></th>
<th><span class="math inline">\(e_1^2\)</span></th>
<th><span class="math inline">\(e_\infty^2\)</span></th>
<th>Ordre partiel</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>10</td>
<td>0.12566E+01</td>
<td>796</td>
<td>0.91045E-01</td>
<td>0.25373E-01</td>
<td>7958</td>
<td>0.23402E+01</td>
<td>0.48973E+00</td>
<td>—</td>
</tr>
<tr class="even">
<td>20</td>
<td>0.62832E+00</td>
<td>1592</td>
<td>0.16296E-01</td>
<td>0.75946E-02</td>
<td>15916</td>
<td>0.24779E+00</td>
<td>0.91331E-01</td>
<td>2.46</td>
</tr>
<tr class="odd">
<td>30</td>
<td>0.41888E+00</td>
<td>2388</td>
<td>0.30697E-02</td>
<td>0.17333E-02</td>
<td>23874</td>
<td>0.33884E-01</td>
<td>0.19089E-01</td>
<td>4.11</td>
</tr>
<tr class="even">
<td>40</td>
<td>0.31416E+00</td>
<td>3184</td>
<td>0.86438E-03</td>
<td>0.49418E-03</td>
<td>31831</td>
<td>0.85959E-02</td>
<td>0.49384E-02</td>
<td>4.40</td>
</tr>
<tr class="odd">
<td>50</td>
<td>0.25133E+00</td>
<td>3979</td>
<td>0.29500E-03</td>
<td>0.17524E-03</td>
<td>39789</td>
<td>0.29360E-02</td>
<td>0.16277E-02</td>
<td>4.81</td>
</tr>
<tr class="even">
<td>60</td>
<td>0.20944E+00</td>
<td>4775</td>
<td>0.12050E-03</td>
<td>0.73274E-04</td>
<td>47747</td>
<td>0.12244E-02</td>
<td>0.71686E-03</td>
<td>4.91</td>
</tr>
<tr class="odd">
<td>70</td>
<td>0.17952E+00</td>
<td>5571</td>
<td>0.57995E-04</td>
<td>0.34643E-04</td>
<td>55705</td>
<td>0.58089E-03</td>
<td>0.34831E-03</td>
<td>4.74</td>
</tr>
<tr class="even">
<td>80</td>
<td>0.15708E+00</td>
<td>6367</td>
<td>0.29736E-04</td>
<td>0.17991E-04</td>
<td>63662</td>
<td>0.29913E-03</td>
<td>0.18170E-03</td>
<td>5.00</td>
</tr>
<tr class="odd">
<td>90</td>
<td>0.13963E+00</td>
<td>7162</td>
<td>0.16721E-04</td>
<td>0.10057E-04</td>
<td>71620</td>
<td>0.16729E-03</td>
<td>0.10091E-03</td>
<td>4.88</td>
</tr>
<tr class="even">
<td>100</td>
<td>0.12566E+00</td>
<td>7958</td>
<td>0.98895E-05</td>
<td>0.59647E-05</td>
<td>79578</td>
<td>0.98436E-04</td>
<td>0.59142E-04</td>
<td>4.98</td>
</tr>
<tr class="odd">
<td>110</td>
<td>0.11424E+00</td>
<td>8754</td>
<td>0.62158E-05</td>
<td>0.37134E-05</td>
<td>87536</td>
<td>0.62044E-04</td>
<td>0.37481E-04</td>
<td>4.87</td>
</tr>
<tr class="even">
<td>120</td>
<td>0.10472E+00</td>
<td>9550</td>
<td>0.40384E-05</td>
<td>0.24170E-05</td>
<td>95493</td>
<td>0.40213E-04</td>
<td>0.24571E-04</td>
<td>4.95</td>
</tr>
<tr class="odd">
<td>130</td>
<td>0.96664E-01</td>
<td>10346</td>
<td>0.27021E-05</td>
<td>0.16371E-05</td>
<td>103451</td>
<td>0.27136E-04</td>
<td>0.16534E-04</td>
<td>5.01</td>
</tr>
<tr class="even">
<td>140</td>
<td>0.89760E-01</td>
<td>11141</td>
<td>0.18766E-05</td>
<td>0.11385E-05</td>
<td>111409</td>
<td>0.18758E-04</td>
<td>0.11398E-04</td>
<td>4.91</td>
</tr>
<tr class="odd">
<td>150</td>
<td>0.83776E-01</td>
<td>11937</td>
<td>0.13286E-05</td>
<td>0.81050E-06</td>
<td>119367</td>
<td>0.13326E-04</td>
<td>0.80321E-05</td>
<td>5.00</td>
</tr>
<tr class="even">
<td>160</td>
<td>0.78540E-01</td>
<td>12733</td>
<td>0.96536E-06</td>
<td>0.58905E-06</td>
<td>127324</td>
<td>0.96469E-05</td>
<td>0.58736E-05</td>
<td>4.94</td>
</tr>
<tr class="odd">
<td>170</td>
<td>0.73920E-01</td>
<td>13529</td>
<td>0.71124E-06</td>
<td>0.43605E-06</td>
<td>135282</td>
<td>0.71128E-05</td>
<td>0.43599E-05</td>
<td>5.03</td>
</tr>
<tr class="even">
<td>180</td>
<td>0.69813E-01</td>
<td>14324</td>
<td>0.53662E-06</td>
<td>0.32814E-06</td>
<td>143240</td>
<td>0.53650E-05</td>
<td>0.32804E-05</td>
<td>4.92</td>
</tr>
<tr class="odd">
<td>190</td>
<td>0.66139E-01</td>
<td>15120</td>
<td>0.41032E-06</td>
<td>0.25064E-06</td>
<td>151198</td>
<td>0.40978E-05</td>
<td>0.24997E-05</td>
<td>4.96</td>
</tr>
<tr class="even">
<td>200</td>
<td>0.62832E-01</td>
<td>15916</td>
<td>0.31724E-06</td>
<td>0.19402E-06</td>
<td>159155</td>
<td>0.32023E-05</td>
<td>0.19290E-05</td>
<td>5.01</td>
</tr>
</tbody>
</table>
<blockquote>
<p>TODO: il n’est pas nécessaire d’avoir autant de ligne, les colonnes <span class="math inline">\(n^{1|2}\)</span> (nombre d’itérations) ne sont peut-être pas nécessaire non plus. Il s’agit d’un tableau de données brutes qu’il est sans doute nécessaire de retravailler pour la mise en page et la lisibilité des données</p>
</blockquote>
<h3 id="schéma-weno">Schéma WENO</h3>
<p>Les schémas numériques d’ordre élevé ont permis d’approfondir l’étude de problèmes complexes comme en mécanique des fluides. L’introduction de l’ordre élevé se fait généralement au détriment d’oscillations pouvant apparaître au niveau des discontinuités. Une famille de schémas numériques d’ordre élevé a été introduite par C.-W. Shu, exposées dans <span class="citation" data-cites="icase">[9]</span> et <span class="citation" data-cites="weno">[10]</span>, permettant de prévenir l’apparition d’oscillation.</p>
<p>WENO pour <em>weighted essentially non-oscillatory</em> est une famille de schémas numériques qui se généralise facilement à l’ordre élevé sans pour autant provoquer d’oscillations. L’idée des schémas WENO est d’effectuer plusieurs interpolations polynomiales lagrangiennes sur des <em>stencils</em> incluant le point à évaluer, pondérées pour limiter les oscillations. La méthode que nous allons présenter ici est un schéma WENO d’ordre 5.</p>
<blockquote>
<p>TODO: Faire un schéma où on remonte une courbe caractéristique et dire que le problème se “limite” à un problème d’interpolation, et que pour limiter les oscillations d’une interpolation polynomiale d’ordre élevé on en fait 3 d’ordre moins élevé, que l’on pondère pour réduire encore plus le risque oscillant.</p>
</blockquote>
<p>Nous présenterons ce schéma toujours à partir de l’équation (<a href="#4.4" class="aeq">4.4</a>). Le schéma WENO de base s’écrit à partir d’une vitesse <span class="math inline">\(a\)</span> pouvant dépendre de <span class="math inline">\(x\)</span>, l’équation de transport s’écrit alors :</p>
<p><span class="math display">\[
  \partial_t u + \partial_x(a u) = 0
\]</span></p>
<p>Dans notre cas, la discrétisation de la vitesse <span class="math inline">\(a\)</span> dépend d’un paramètre <span class="math inline">\(k\)</span> indépendant de <span class="math inline">\(i\)</span> (discrétisation de l’espace des phases), nous noterons par conséquent cette discrétisation <span class="math inline">\(a_k\)</span>. Cette notation permettra d’écrire directement le schéma en espace de la partie <em>micro</em> en substituant <span class="math inline">\(a_k\)</span> par <span class="math inline">\(v_k\)</span> et <span class="math inline">\(u_{i,k}\)</span> par <span class="math inline">\(g_{i,k}\)</span>. Pour alléger les notations, nous nous placerons au temps <span class="math inline">\(t^n\)</span>. Nous souhaitons approximer <span class="math inline">\(\partial_x(au)_{|x=x_i,v=v_k}\)</span> :</p>
<p><span class="math display">\[
  \partial(au)_{|x=x_i,v=v_k} \approx \frac{1}{\Delta x}(\hat{u}_{i+\frac{1}{2},k} - \hat{u}_{i-\frac{1}{2},k})
\]</span></p>
<p>où <span class="math inline">\(\hat{u}_{i,k}\)</span> est une approximation de <span class="math inline">\((au)_{i,k}\)</span> et <span class="math inline">\(\hat{u}_{i+\frac{1}{2},k}\)</span> est le flux numérique. Nous allons distinguer les cas <span class="math inline">\(a_k &gt;0\)</span> et <span class="math inline">\(a_k &lt;0\)</span> en écrivant <span class="math inline">\(\hat{u}\)</span> comme :</p>
<p><span class="math display">\[
  \hat{u}_{i,k} = \hat{u}_{i,k}^+ + \hat{u}_{i,k}^-
\]</span></p>
<p>où :</p>
<ul>
<li><span class="math inline">\(\hat{u}_{i.k}^+ = a^+u_{i,k} = \max(a_k,0)u_{i,k}\)</span></li>
<li><span class="math inline">\(\hat{u}_{i.k}^- = a^-u_{i,k} = \min(a_k,0)u_{i,k}\)</span></li>
</ul>
<p>Chaque flux numérique est donnée par la somme pondérée de 3 approximations sur 3 <em>stencils</em> différents :</p>
<p><span class="math display">\[
  \begin{aligned}
    \hat{u}_{i+\frac{1}{2},k}^+ =\,&amp;w_0^+\left(\frac{2}{6}u_{i-2,k}^+ - \frac{7}{6}u_{i-1,k}^+ + \frac{11}{6}u_{i,k}^+\right)
                        +   w_1^+\left(-\frac{1}{6}u_{i-1,k}^+ + \frac{5}{6}u_{i,k}^+   +  \frac{2}{6}u_{i+1,k}^+\right) \\
                        +\,&amp;w_2^+\left( \frac{2}{6}u_{i,k}^+   + \frac{5}{6}u_{i+1,k}^+ -  \frac{1}{6}u_{i+2,k}^+\right)
  \end{aligned}
\]</span></p>
<p>et</p>
<p><span class="math display">\[
  \begin{aligned}
  \hat{u}_{i+\frac{1}{2},k}^- =\,&amp;w_2^-\left(-\frac{1}{6}u_{i-1,k}^- + \frac{5}{6}u_{i,k}^-   + \frac{2}{6}u_{i+1,k}^-\right)
                        +   w_1^-\left( \frac{2}{6}u_{i,k}^-   + \frac{5}{6}u_{i+1,k}^- - \frac{1}{6}u_{i+2,k}^-\right) \\
                        +\,&amp;w_0^-\left(\frac{11}{6}u_{i+1,k}^- - \frac{7}{6}u_{i+2,k}^- + \frac{2}{6}u_{i+3,k}^-\right)
  \end{aligned}
\]</span></p>
<p>Les poids non linéaires <span class="math inline">\(w_{n}^{\pm}\)</span> sont des fractions rationnelles données par :</p>
<p><span class="math display">\[
  w_{n}^{\pm} = \frac{\tilde{w}_{n}^{\pm}}{\sum_{m=0}^2 \tilde{w}_{m}^{\pm} } \,, \quad \tilde{w}_{n}^{\pm} = \frac{\gamma_n}{(\epsilon + \beta_{n}^{\pm})^2}
\]</span></p>
<p>avec les poids linéaires <span class="math inline">\(\gamma_{n}\)</span> donnés par :</p>
<p><span class="math display">\[
  \gamma_{0} = \frac{1}{10} \,, \quad \gamma_{1} = \frac{3}{5}\,,\quad \gamma_{2} = \frac{3}{10}
\]</span></p>
<p>et les indicateurs de continuités <span class="math inline">\(\beta_n^{\pm}\)</span> donnés par :</p>
<p><span class="math display">\[
 \begin{aligned}
   \beta_0^+ &amp;= \frac{13}{12}(u^+_{i-2,k} -2u^+_{i-1,k} + u^+_{i  ,k})^2 + \frac{1}{4}( u^+_{i-2,k} - 4u^+_{i-1,k} + 3u^+_{i,k})^2 \\
   \beta_1^+ &amp;= \frac{13}{12}(u^+_{i-1,k} -2u^+_{i  ,k} + u^+_{i+1,k})^2 + \frac{1}{4}( u^+_{i-1,k} -  u^+_{i+1,k})^2 \\
   \beta_2^+ &amp;= \frac{13}{12}(u^+_{i  ,k} -2u^+_{i+1,k} + u^+_{i+2,k})^2 + \frac{1}{4}(3u^+_{i  ,k} - 4u^+_{i+1,k} + u^+_{i+2,k} )^2 
 \end{aligned}
\]</span></p>
<p>et</p>
<p><span class="math display">\[
 \begin{aligned}
   \beta_0^- &amp;= \frac{13}{12}(u^-_{i+1,k} -2u^-_{i+2,k} + u^-_{i+3,k})^2 + \frac{1}{4}(3u^-_{i+1,k} - 4u^-_{i+2,k} + u^-_{i+3,k})^2 \\
   \beta_1^- &amp;= \frac{13}{12}(u^-_{i  ,k} -2u^-_{i+1,k} + u^-_{i+2,k})^2 + \frac{1}{4}(u^-_{i,k} - u^-_{i+2,k})^2 \\
   \beta_2^- &amp;= \frac{13}{12}(u^-_{i-1,k} -2u^-_{i  ,k} + u^-_{i+1,k})^2 + \frac{1}{4}(u^-_{i,k} - 4u^-_{i,k} + 3u^-_{i+1,k})^2
 \end{aligned}
\]</span></p>
<p>et enfin, <span class="math inline">\(\epsilon\)</span> est un paramètre pour prévenir que le dénominateur soit égal à <span class="math inline">\(0\)</span> ; il est généralement pris à <span class="math inline">\(\epsilon = 10^{-6}\)</span> (dans <span class="citation" data-cites="weno">[10]</span>) ou <span class="math inline">\(\epsilon = 10^{-5}\times\max_{i,k}( a^0_k u^0_{i})\)</span> (dans <span class="citation" data-cites="qiu">[11]</span>) ; ce dernier cas présente l’avantage de s’adapter à l’amplitude de la fonction à considérer.</p>
<p>On a ainsi définit l’approximation du terme de transport à l’aide d’un schéma WENO pour toute vitesse <span class="math inline">\(a_k\)</span> :</p>
<p><span class="math display">\[
  \partial_x (au)_{|x=x_i,y=y_k} \approx \frac{1}{\Delta x}\left[ (\hat{u}^+_{i+\frac{1}{2},k} - \hat{u}^+_{i-\frac{1}{2},k}) + (\hat{u}^-_{i+\frac{1}{2},k} - \hat{u}^-_{i-\frac{1}{2},k}) \right] 
\]</span></p>
<h4 id="obtention-de-lordre-en-espace-1">Obtention de l’ordre en espace</h4>
<p>Comme précédemment nous allons calculer l’ordre à l’aide du transport à vitesse constante <span class="math inline">\(a\)</span>, en utilisant une fonction cosinus comme condition initiale. Nous allons résoudre successivement ce problème de transport sur un maillage de plus en plus fin.</p>
<p>Le problème que nous considérons est (<a href="#4.4" class="aeq">4.4</a>) avec <span class="math inline">\(a=1\)</span> :</p>
<p><span class="math display">\[
  \partial_t u + \partial_x u = 0
\]</span></p>
<p>Un test similaire a été effectué à vitesse négative au vu du changement de formulation pour ce cas. L’équation est considérée valide sur l’ensemble <span class="math inline">\(x\in[0,2\pi]\)</span> avec des conditions aux bords périodiques ; et nous allons considérer un cosinus comme condition initiale :</p>
<p><span class="math display">\[
  u_i^0 = \cos(x_i)
\]</span></p>
<p>avec <span class="math inline">\(x_i = i\Delta x\)</span> et le pas d’espace <span class="math inline">\(\Delta x = \frac{2\pi}{N}\)</span> où <span class="math inline">\(N\)</span> est le nombre de points du maillage. La solution exacte au temps <span class="math inline">\(t^n\)</span> est :</p>
<p><span class="math display">\[
  u_i^n = \cos(x_i - t^n)
\]</span></p>
<p>Pour ce schéma nous utiliserons uniquement la mesure de l’ordre avec un nombre de CFL constant, ce qui permet de réduire l’erreur en temps à mesure que le maillage se raffine.</p>
<p>Les différentes simulations sont effectuées avec un nombre de CFL constant, c’est-à-dire :</p>
<p><span class="math display">\[
  \frac{\Delta t}{\Delta x} = c
\]</span></p>
<p>donc <span class="math inline">\(\Delta t = c\frac{2\pi}{N}\)</span> change à chaque raffinement de maillage.</p>
<figure>
<img src="img/ordre_wenop.png" alt="Mesure de l’ordre sur plusieurs itérations" /><figcaption>Mesure de l’ordre sur plusieurs itérations</figcaption>
</figure>
<p>La figure (TODO référence de la figure) montre l’évolution de l’erreur en fonction du pas d’espace <span class="math inline">\(\Delta x\)</span> en échelle logarithmique. L’erreur est indiquée pour 2 temps distincts <span class="math inline">\(t_1= 0.1\)</span> et <span class="math inline">\(t_2 = 1\)</span> pour un nombre de CFL égal à <span class="math inline">\(c = 10^{-5}\)</span>. En comparant ces résultats par rapport à ceux du schéma compact, l’ordre donné via le graphique est plus élevé (on peut déterminer déjà une valeur de <span class="math inline">\(5\)</span>). On remarque aussi que l’erreur systématique du schéma est beaucoup plus faible. Ainsi le <em>plongeon</em> de l’erreur que l’on peut observer sur les valeurs à gauche est plus dû au bruit de l’erreur machine qu’à un véritable schéma d’ordre <span class="math inline">\(7\)</span> (dernière valeur de l’ordre partiel présent dans le tableau suivant).</p>
<table>
<caption>Erreur et ordre au temps <span class="math inline">\(t^1 = 0.1\)</span> et <span class="math inline">\(t^2=1\)</span></caption>
<colgroup>
<col style="width: 4%" />
<col style="width: 12%" />
<col style="width: 7%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 7%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 18%" />
</colgroup>
<thead>
<tr class="header">
<th><span class="math inline">\(m\)</span></th>
<th><span class="math inline">\(\Delta x\)</span></th>
<th><span class="math inline">\(n^1\)</span></th>
<th><span class="math inline">\(e_1^1\)</span></th>
<th><span class="math inline">\(e_\infty^1\)</span></th>
<th><span class="math inline">\(n^2\)</span></th>
<th><span class="math inline">\(e_1^2\)</span></th>
<th><span class="math inline">\(e_\infty^2\)</span></th>
<th>Ordre partiel</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>10</td>
<td>0.62832E+00</td>
<td>1592</td>
<td>0.37995E-05</td>
<td>0.13973E-05</td>
<td>15916</td>
<td>0.37846E-04</td>
<td>0.13958E-04</td>
<td>—</td>
</tr>
<tr class="even">
<td>20</td>
<td>0.31416E+00</td>
<td>3184</td>
<td>0.17447E-06</td>
<td>0.51436E-07</td>
<td>31831</td>
<td>0.17442E-05</td>
<td>0.51362E-06</td>
<td>4.44475868534761</td>
</tr>
<tr class="odd">
<td>30</td>
<td>0.20944E+00</td>
<td>4775</td>
<td>0.21990E-07</td>
<td>0.64814E-08</td>
<td>47747</td>
<td>0.21986E-06</td>
<td>0.64666E-07</td>
<td>5.10812141688064</td>
</tr>
<tr class="even">
<td>40</td>
<td>0.15708E+00</td>
<td>6367</td>
<td>0.50685E-08</td>
<td>0.15061E-08</td>
<td>63662</td>
<td>0.50680E-07</td>
<td>0.15011E-07</td>
<td>5.10126639529244</td>
</tr>
<tr class="odd">
<td>50</td>
<td>0.12566E+00</td>
<td>7958</td>
<td>0.16195E-08</td>
<td>0.48771E-09</td>
<td>79578</td>
<td>0.16194E-07</td>
<td>0.48569E-08</td>
<td>5.11224599339332</td>
</tr>
<tr class="even">
<td>60</td>
<td>0.10472E+00</td>
<td>9550</td>
<td>0.64017E-09</td>
<td>0.19434E-09</td>
<td>95493</td>
<td>0.64014E-08</td>
<td>0.19335E-08</td>
<td>5.09155944269373</td>
</tr>
<tr class="odd">
<td>70</td>
<td>0.89760E-01</td>
<td>11141</td>
<td>0.29164E-09</td>
<td>0.89188E-10</td>
<td>111409</td>
<td>0.29163E-08</td>
<td>0.88654E-09</td>
<td>5.10029279160139</td>
</tr>
<tr class="even">
<td>80</td>
<td>0.78540E-01</td>
<td>12733</td>
<td>0.14769E-09</td>
<td>0.45325E-10</td>
<td>127324</td>
<td>0.14768E-08</td>
<td>0.45101E-09</td>
<td>5.09546608574089</td>
</tr>
<tr class="odd">
<td>90</td>
<td>0.69813E-01</td>
<td>14324</td>
<td>0.80818E-10</td>
<td>0.24858E-10</td>
<td>143240</td>
<td>0.80816E-09</td>
<td>0.24901E-09</td>
<td>5.11866013879769</td>
</tr>
<tr class="even">
<td>100</td>
<td>0.62832E-01</td>
<td>15916</td>
<td>0.47041E-10</td>
<td>0.14550E-10</td>
<td>159155</td>
<td>0.47040E-09</td>
<td>0.14591E-09</td>
<td>5.13669351040521</td>
</tr>
<tr class="odd">
<td>110</td>
<td>0.57120E-01</td>
<td>17508</td>
<td>0.28707E-10</td>
<td>0.89342E-11</td>
<td>175071</td>
<td>0.28705E-09</td>
<td>0.89616E-10</td>
<td>5.18180290307426</td>
</tr>
<tr class="even">
<td>120</td>
<td>0.52360E-01</td>
<td>19099</td>
<td>0.18209E-10</td>
<td>0.56994E-11</td>
<td>190986</td>
<td>0.18208E-09</td>
<td>0.57143E-10</td>
<td>5.23178731178777</td>
</tr>
<tr class="odd">
<td>130</td>
<td>0.48332E-01</td>
<td>20691</td>
<td>0.11900E-10</td>
<td>0.37434E-11</td>
<td>206902</td>
<td>0.11899E-09</td>
<td>0.37558E-10</td>
<td>5.31396000767932</td>
</tr>
<tr class="even">
<td>140</td>
<td>0.44880E-01</td>
<td>22282</td>
<td>0.79686E-11</td>
<td>0.25192E-11</td>
<td>222817</td>
<td>0.79671E-10</td>
<td>0.25277E-10</td>
<td>5.4118878574993</td>
</tr>
<tr class="odd">
<td>150</td>
<td>0.41888E-01</td>
<td>23874</td>
<td>0.54306E-11</td>
<td>0.17266E-11</td>
<td>238733</td>
<td>0.54306E-10</td>
<td>0.17326E-10</td>
<td>5.55795381912175</td>
</tr>
<tr class="even">
<td>160</td>
<td>0.39270E-01</td>
<td>25465</td>
<td>0.37499E-11</td>
<td>0.11992E-11</td>
<td>254648</td>
<td>0.37501E-10</td>
<td>0.12037E-10</td>
<td>5.73797548489796</td>
</tr>
<tr class="odd">
<td>170</td>
<td>0.36960E-01</td>
<td>27057</td>
<td>0.26084E-11</td>
<td>0.84055E-12</td>
<td>270564</td>
<td>0.26079E-10</td>
<td>0.84339E-11</td>
<td>5.98753700307258</td>
</tr>
<tr class="even">
<td>180</td>
<td>0.34907E-01</td>
<td>28648</td>
<td>0.18182E-11</td>
<td>0.59053E-12</td>
<td>286479</td>
<td>0.18181E-10</td>
<td>0.59238E-11</td>
<td>6.31491121102708</td>
</tr>
<tr class="odd">
<td>190</td>
<td>0.33069E-01</td>
<td>30240</td>
<td>0.12607E-11</td>
<td>0.41400E-12</td>
<td>302395</td>
<td>0.12602E-10</td>
<td>0.41499E-11</td>
<td>6.76968883229296</td>
</tr>
<tr class="even">
<td>200</td>
<td>0.31416E-01</td>
<td>31831</td>
<td>0.86049E-12</td>
<td>0.28710E-12</td>
<td>318310</td>
<td>0.86084E-11</td>
<td>0.28748E-11</td>
<td>7.44789538520894</td>
</tr>
</tbody>
</table>
<p>Un des intérêts des schémas WENO est qu’il se généralise facilement au cas multi-dimensionnel. En effet, le passage aux dimensions supérieures à <span class="math inline">\(1\)</span> s’effectue par addition des différentes approximations des dérivées dans chaque direction.</p>
<p>Il est donc intéressant d’étudier des cas de transports en 2 dimensions :</p>
<p><span class="math display">\[
  \partial_t u + a \partial_x u + b \partial_y u = 0
\]</span></p>
<p>où <span class="math inline">\(x\)</span> et <span class="math inline">\(y\)</span> sont les deux directions de l’espace, dans lequel nous effectuons un transport à vitesse <span class="math inline">\(a\)</span> dans la direction <span class="math inline">\(x\)</span> et <span class="math inline">\(b\)</span> selon <span class="math inline">\(y\)</span>. La solution exacte est connue pour plusieurs cas tests tels que la translation en 2 dimensions (avec <span class="math inline">\(a\)</span> et <span class="math inline">\(b\)</span> des constantes), ou pour le cas d’une rotations (avec <span class="math inline">\(a(x,y)=y\)</span> et <span class="math inline">\(b(x,y)=-x\)</span>).</p>
<h4 id="test-de-viscosité">Test de viscosité</h4>
<p>À partir du cas test de la rotation avec des conditions aux bords périodiques :</p>
<p><span class="math display">\[
  \partial_t u + y\partial_x u -x\partial_y u = 0
\]</span></p>
<p>il est possible de mettre à l’épreuve la viscosité numérique du schéma. C’est ce qui est effectué dans <span class="citation" data-cites="qiu2011">[12]</span>, avec 12 rotations d’une condition initiale discontinue.</p>
<blockquote>
<p>Cas où l’on fait tourner 12 fois un pacman : <span class="citation" data-cites="qiu2011">[12]</span></p>
</blockquote>
<h4 id="problème-dinstabilité">Problème d’instabilité</h4>
<p>R. Wang et R. Spiteri démontrent dans <span class="citation" data-cites="weno_time">[13]</span> que l’utilisation conjointe du schéma WENO d’ordre 5 avec un schéma temporel de type d’Euler explicite est instable. Nous confirmons ce résultat numériquement avec la rotation d’une gaussienne en temps long. On remarque qu’une discrétisation en temps de Runge-Kutta d’ordre 3 stabilise le schéma. C’est cette instabilité qui nous a conduit à utiliser un nombre de CFL arbitrairement très petit <span class="math inline">\(c=10^{-5}\)</span> dans le test 1D.</p>
<blockquote>
<p>TODO: cas où l’on fait tourner une gaussienne, comparer entre Euler et RK3 (apparition d’une <em>vague de traine</em> dans le cas Euler)</p>
</blockquote>
<blockquote>
<p>TODO: mettre cette même rotation de gaussienne avec <em>upwind</em> et schéma compact ? <em>upwind</em> est très visqueux et on ne voit plus rien en temps long</p>
</blockquote>
<h2 id="couplage-de-léquation-de-transport-et-du-terme-de-raideur">Couplage de l’équation de transport et du terme de raideur</h2>
<p>Dans cette section, on applique les schémas précédents au modèle <em>micro-macro</em>, ce qui va amener à des études supplémentaires comme le calcul de la condition de CFL, ou la reformulation exponentielle du modèle.</p>
<h3 id="calcul-de-la-condition-cfl">Calcul de la condition CFL</h3>
<p>Le terme raide, apporté par l’opérateur de collision BGK va induire une modification de la condition CFL habituelle lors du couplage du schéma d’Euler implicite-explicite avec un schéma en espace.</p>
<p>Pour calculer le nombre de CFL nous allons dans un premier temps nous intéresser au modèle cinétique (<a href="#2.7" class="aeq">2.7</a>) avec <span class="math inline">\(Q(f) = \frac{1}{\varepsilon}(\mathcal{M}_{[f]}-f)\)</span>, la description microscopique du modèle <em>micro-macro</em> est similaire et implique la même condition. Nous utiliserons le schéma d’Euler implicite pour la discrétisation en temps de <span class="math inline">\(Q(f)\)</span>, et pour simplifier les notations nous n’utiliserons qu’un schéma <em>upwind</em> en espace, encore une fois le champ électrique est négligé dans cette partie.</p>
<p><span class="math display">\[
  \frac{f_{j,k}^{n+1}-f_{j,k}^n}{\Delta t} + v_k\frac{f_{j+\frac{1}{2},k}^n - f_{j-\frac{1}{2},k}^n}{\Delta x} = \frac{1}{\varepsilon}((\mathcal{M}_{[f^{n+1}]})_{j,k} - f_{j,k}^{n+1})
\]</span></p>
<p>Le calcul de <span class="math inline">\(\mathcal{M}_{[f^{n+1}]}\)</span> sera explicité dans la section <a href="#discrétisation-du-modèle-cinétique">5.1</a>. Cette équation peut se réécrire, pour une interprétation itérative :</p>
<p><span class="math display">\[
  f_{j,k}^{n+1} = \frac{1}{1+\frac{\Delta t}{\varepsilon}}\left[ f_{j,k}^n - v_k\frac{\Delta t}{\Delta x}(f_{j+\frac{1}{2},k}^n - f_{j-\frac{1}{2},k}^n) + \frac{\Delta t}{\varepsilon}(\mathcal{M}_{[f^{n+1}]})_{j,k} \right]
\]</span></p>
<p>Nous allons utiliser l’analyse de von Neumann pour déterminer la condition CFL, méthode décrite dans <span class="citation" data-cites="anm1966">[14]</span>. Cette méthode implique le calcul d’une transformée de Fourier discrète, nous nous plaçons donc dans l’intervalle <span class="math inline">\(\Omega = [0,2\pi]\)</span> avec des conditions aux bords périodiques, c’est-à-dire <span class="math inline">\(f(t,x+2\pi,v) = f(t,x,v)\,\forall t,x,v\)</span>. Puisque les fonctions formant la base de la transformée de Fourier sont orthogonales, nous pouvons nous intéresser au comportement de chaque mode indépendament, puis majorer l’ensemble des modes pour étudier le comportement global.</p>
<p>Le coefficient de Fourier du mode <span class="math inline">\(\kappa\)</span> de <span class="math inline">\((f_{j,k}^n)_{i,k}\)</span> est donné par :</p>
<p><span class="math display">\[
  f_{j,k}^n = e^{i\kappa j\Delta x}A^n_{k}
\]</span></p>
<p>où <span class="math inline">\(i\)</span> est le nombre imaginaire tel que <span class="math inline">\(i^2 = -1\)</span>. Nous pouvons donc facilement exprimer <span class="math inline">\(f_{j-1,k}^n\)</span> directement en fonction de <span class="math inline">\(f_{j,k}^n\)</span> :</p>
<p><span class="math display">\[
  f_{j-1,k}^n = e^{i\kappa (j-1)\Delta x}A^n_k = f_{j,k}^n e^{-i\kappa\Delta x}
\]</span></p>
<p>Cela permet donc d’exprimer <span class="math inline">\(f_{j,k}^{n+1}\)</span> en fonction uniquement de <span class="math inline">\(f_{j,k}^n\)</span>, et donc d’obtenir une formule de récurrence du type :</p>
<p><span class="math display">\[
  f_{j,k}^{n+1} = \mathcal{A} f_{j,k}^n = (\mathcal{A})^{n+1} f_{j,k}^0
\]</span></p>
<p>où <span class="math inline">\(\mathcal{A}\)</span> est appelé coefficient d’amplification. On remarque qu’il est nécessaire pour que le schéma soit stable dans <span class="math inline">\(L^2\)</span> d’avoir <span class="math inline">\(|\mathcal{A}| \leq 1\)</span>. Pour trouver cette formule de récurrence nous travaillerons sur une version simplifiée du schéma en négligeant l’impact de la maxwellienne.</p>
<p>On part ainsi du schéma simplifié sur <span class="math inline">\(f\)</span> :</p>
<p><span class="math display">\[
  f_{j,k}^{n+1} = \frac{\varepsilon}{\varepsilon + \Delta t}\left[ f_{j,k}^n - \frac{\Delta t}{\Delta x}v_k(f_{j,k}^n - f_{j,k}^ne^{-i\kappa\Delta x} )  \right]
\]</span></p>
<p>Ce que l’on peut écrire sous la forme :</p>
<p><span class="math display">\[
  f_{j,k}^{n+1} = f_{j,k}^n\frac{\varepsilon}{\varepsilon + \Delta t}\left[ 1-\frac{\Delta t}{\Delta x}v_k(1-e^{-i\kappa\Delta x}) \right]
\]</span></p>
<p>On obtient bien la forme désirée <span class="math inline">\(f_{j,k}^{n+1} = \mathcal{A} f_{j,k}\)</span>. Pour simplifier l’étude de <span class="math inline">\(\mathcal{A}\)</span> écrivons ce terme sous la forme :</p>
<p><span class="math display">\[
  \mathcal{A} = \frac{\varepsilon}{\varepsilon + \Delta t} \mathcal{B}
\]</span></p>
<p>Étudions <span class="math inline">\(|\mathcal{B}|^2\)</span> :</p>
<ul>
<li><span class="math inline">\(\mathrm{Im}(\mathcal{B}) = -\frac{\Delta t}{\Delta x}v_k\sin(\kappa \Delta x)\)</span></li>
<li><span class="math inline">\(\mathrm{Re}(\mathcal{B}) = 1-\frac{\Delta t}{\Delta x}v_k(1-\cos(\kappa \Delta x)\)</span></li>
</ul>
<p>D’où :</p>
<p><span class="math display">\[
  \begin{aligned}
    |\mathcal{B}|^2 &amp;= \mathrm{Re}(\mathcal{B})^2 + \mathrm{Im}(\mathcal{B})^2 \\
                    &amp;= 1 + 2(1-\cos(\kappa\Delta x))\Delta t \left[ \frac{\Delta t}{\Delta x^2}v_k^2 - \frac{v_k}{\Delta x}\right] \\
  \end{aligned}
\]</span></p>
<p>On souhaite <span class="math inline">\(|\mathcal{A}|^2 = \left(\frac{\varepsilon}{\varepsilon + \Delta t}\right)^2|\mathcal{B}|^2 \leq 1\)</span> c’est-à-dire :</p>
<p><span class="math display">\[
  |\mathcal{B}|^2 \leq \left(\frac{\varepsilon + \Delta t}{\varepsilon}\right)^2
\]</span></p>
<p>Ce que l’on peut reformuler comme suit, pour majorer <span class="math inline">\(\Delta t\)</span> :</p>
<p><span class="math display">\[
    \Delta t \left[(1-\cos(\kappa\Delta x))\frac{v_k^2}{\Delta x^2} - \frac{1}{2\varepsilon^2}\right] \leq \frac{1}{\varepsilon} + (1-\cos(\kappa\Delta x))\frac{v_k}{\Delta x}
\]</span></p>
<p>Cette inégalité doit être vérifiée pour toute vitesse <span class="math inline">\(v_k\)</span> nous allons donc majorer par <span class="math inline">\(v_{\textrm{max}}\)</span>, de même quelque soit le nombre d’onde <span class="math inline">\(\kappa\)</span> nous allons donc majorer <span class="math inline">\(1-\cos(\kappa\Delta x)=2\sin^2(\frac{\kappa\Delta x}{2})\)</span> par 2. Ce qui nous donne après simplification :</p>
<p><span class="math display">\[
  \Delta t (2v\varepsilon - \Delta x) \leq 2\Delta x \varepsilon
\]</span></p>
<p>Il est nécessaire d’étudier le signe de <span class="math inline">\(2v\varepsilon - \Delta x\)</span> :</p>
<ul>
<li><p><span class="math inline">\(2v\varepsilon - \Delta x &lt; 0\)</span> alors <span class="math inline">\(\Delta t &gt;0\)</span> ce qui est toujours vérifié. Cette condition est vérifiée si :</p>
<p><span class="math display">\[
  \varepsilon &lt; \frac{\Delta x}{2v}
\]</span></p>
Avec classiquement <span class="math inline">\(\Delta x \sim 10^{-2}\)</span> et <span class="math inline">\(v\sim 18\)</span> ce qui nous donne <span class="math inline">\(\varepsilon \sim 10^{-3}\)</span>.</li>
<li><p><span class="math inline">\(2v\varepsilon - \Delta x &gt; 0\)</span> alors :</p>
<p><span class="math display">\[
  \Delta t \leq \frac{2\Delta x \varepsilon}{2v\varepsilon - \Delta x}
\]</span></p></li>
</ul>
<p>En étudiant la fonction :</p>
<p><span class="math display">\[
  \mathscr{C}:\varepsilon\mapsto\frac{ \frac{\Delta x}{v} \varepsilon}{\varepsilon - \frac{1}{2}\frac{\Delta x}{v}}
\]</span></p>
<blockquote>
<p>TODO: tracer cette fonction</p>
</blockquote>
<p>on trouve que cette fonction est décroissante et a pour limite <span class="math inline">\(\frac{\Delta x}{v}\)</span>, nous utiliserons donc une fraction de cette limite comme base de temps. On retrouve aussi le pôle <span class="math inline">\(\frac{\Delta x}{2v}\)</span> qui correspond au changement de condition pour obtenir <span class="math inline">\(\Delta t\)</span>.</p>
<h3 id="reformulation-exponentielle-du-modèle-micro">Reformulation exponentielle du modèle <em>micro</em></h3>
<p>Au sein du modèle <em>micro-macro</em> (<a href="#3.4" class="aeq">3.4</a>), la partie <em>micro</em> fait intervenir un terme de collision : <span class="math inline">\(\frac{1}{\varepsilon}g\)</span>, ce terme empêche d’utiliser directement une autre discrétisation en temps que le schéma Euler implicite ou explicite. Or en proposant de l’ordre élevé en espace il devient intéressant, voir indispensable, de monter l’ordre en temps. En effet R. Wang et R. Spiteri démontrent dans <span class="citation" data-cites="weno_time">[13]</span> qu’il est impossible de satisfaire la condition CFL d’un schéma composé d’une partie spatiale résolue par un schéma WENO d’ordre 5, et d’une partie temporelle résolue par un schéma d’Euler implicite. Le terme raide en <span class="math inline">\(\frac{1}{\varepsilon}\)</span> ne permet pas de revenir à un cas stable. Il est nécessaire de modifier la formulation du modèle <em>micro</em> pour faire intervenir une discrétisation du schéma de Runge-Kutta d’ordre au moins 3 (RK3).</p>
<p>Nous rappelons le modèle <em>micro</em> :</p>
<p><span class="math display">\[
  \partial_t g + (I-\Pi)(v\partial_x(\mathcal{M}_{[f]}+g) + E\partial_v(\mathcal{M}_{[f]}+g)) = -\frac{1}{\varepsilon}g
\]</span><a href="#4.6" id="4.6" class="eq"></a></p>
<p>En remarquant que :</p>
<p><span class="math display">\[
  \partial_t g+\frac{1}{\varepsilon}g = e^{-\frac{t}{\varepsilon}}\partial_t\left(e^{\frac{t}{\varepsilon}}g\right)
\]</span></p>
<p>On pose donc <span class="math inline">\(\zeta = e^{\frac{t}{\varepsilon}}g\)</span>, l’équation (<a href="#4.6" class="aeq">4.6</a>) devient donc :</p>
<p><span class="math display">\[
  \partial_t \zeta +(I-\Pi)(v\partial_x(\zeta+e^{\frac{t}{\varepsilon}}\mathcal{M}_{[f]})+E\partial_v(\zeta+e^{\frac{t}{\varepsilon}}\mathcal{M}_{[f]})) = 0
\]</span></p>
<p>Il devient donc possible d’appliquer une discrétisation type Runge-Kutta d’ordre 3, avec :</p>
<p><span class="math display">\[
  L(u,t) = -(I-\Pi)(v\partial_x(u+e^{\frac{t}{\varepsilon}}\mathcal{M}_{[f]})+E\partial_v(u+e^{\frac{t}{\varepsilon}}\mathcal{M}_{[f]}))
\]</span></p>
<p>Ceci revient à utiliser les schémas de Lawson <span class="citation" data-cites="siam1967">[15]</span>.</p>
<h2 id="résolution-du-problème-de-poisson">Résolution du problème de Poisson</h2>
<p>Pour résoudre le problème de Poisson en condition aux bords périodiques nous utiliserons une méthode de transformée de Fourier. Le champ électrique est une fonction de la densité <span class="math inline">\(\rho(t^n)\)</span>, il est donc nécessaire de résoudre le problème de Poisson à chaque pas de temps, et à chaque sous-étape dans le cas du schéma RK3.</p>
<p>Notons <span class="math inline">\(\varrho = \rho -1\)</span>, il suffit de calculer la transformée de Fourier de <span class="math inline">\(\varrho\)</span> pour résoudre le problème (<a href="#2.5" class="aeq">2.5</a>) dans le contexte spectral :</p>
<p><span class="math display">\[
  i\kappa \hat{E}_{\kappa} = \hat{\varrho}_{\kappa}
\]</span></p>
<p>où <span class="math inline">\(\kappa\)</span> est l’indice du coefficient de Fourier et <span class="math inline">\(i\)</span> le nombre complexe tel que <span class="math inline">\(i^2 = -1\)</span>. Ainsi on définit pour tout <span class="math inline">\(\kappa\)</span> le coefficient de Fourier :</p>
<ul>
<li><span class="math inline">\(\hat{E}_{\kappa} = -i\displaystyle\frac{\hat{\varrho}_{\kappa}}{\kappa}\)</span> si <span class="math inline">\(\kappa \neq 0\)</span></li>
<li><span class="math inline">\(\hat{E}_0 = 0\)</span> car <span class="math inline">\(E_f\)</span> est à moyenne nulle d’après la condition (<a href="#2.6" class="aeq">2.6</a>)</li>
</ul>
<p>Ainsi tous les coefficients de Fourrier de <span class="math inline">\(E_f\)</span> sont calculés, il suffit d’effectuer la transformée inverse pour trouver le résultat souhaité.</p>
<h1 id="application-aux-modèles-cinétiques-et-micro-macro">Application aux modèles cinétiques et <em>micro-macro</em></h1>
<p>Nous avons appliqué les schémas précédents à différents modèles :</p>
<ul>
<li>Un modèle cinétique sur <span class="math inline">\(f\)</span> (<a href="#2.3" class="aeq">2.3</a>) qui permettra de tester nos schémas cinétiques sans couplage avec des équations de type Euler.</li>
<li>Le modèle <em>micro-macro</em> (<a href="#3.4" class="aeq">3.4</a>) qui couple la discrétisation de la parrtie cinétique <em>micro</em> à la partie fluide de type Euler.</li>
<li>Le modèle <em>micro-macro</em> avec une fonction <span class="math inline">\(h\)</span> qui permettra de tester cette nouvelle modélisation.</li>
</ul>
<h2 id="discrétisation-du-modèle-cinétique">Discrétisation du modèle cinétique</h2>
<blockquote>
<p>Algorithme, propriété de la température et conservation des variables intensives, calcul de CFL, tests numériques (périodique et Neumann) comparaison avec Euler</p>
</blockquote>
<p>Dans un premier temps, pour pouvoir comparer les résultats avec un code de simulation des équations d’Euler, on étudie le modèle sans champ électrique <span class="math inline">\(E\)</span>, c’est-à-dire le modèle suivant :</p>
<p><span class="math display">\[
  \partial_t f + v\partial_x f = \frac{1}{\varepsilon}(\mathcal{M}_{[f]}-f)
\]</span></p>
<p>La résolution nécessite une grille en espace et en vitesse, c’est-à-dire un maillage de l’espace des phases. On note <span class="math inline">\(f_{i,k}^n\)</span> l’approximation de <span class="math inline">\(f(t^n,x_i,v_k)\)</span>. On suppose <span class="math inline">\(f_{i,k}^n\)</span> donnée par l’itération précédente, le calcul de la nouvelle itération s’effectue schématiquement comme suit :</p>
<ol type="1">
<li>On calcule le flux numérique <span class="math inline">\(f_{i+\frac{1}{2},k}^n\)</span> du schéma en espace souhaité (<em>upwind</em>, schéma compact ou WENO) :</li>
</ol>
<p><span class="math display">\[
    f_{i+\frac{1}{2},k}^n \gets ((f_{j,k}^n)_{j\in[i-2;i+2]},v_k)
  \]</span></p>
<ol start="2" type="1">
<li>On calcule le flux numérique <span class="math inline">\(F_{i+\frac{1}{2}}^n\)</span> pour le schéma macro sur <span class="math inline">\(U\)</span> à partir du flux <span class="math inline">\(f_{i+\frac{1}{2},k}^n\)</span> :</li>
</ol>
<p><span class="math display">\[
    F_{i+\frac{1}{2}}^n \gets \sum_k v_km(v_k)f_{i+\frac{1}{2},k}^n\Delta v
  \]</span></p>
<ol start="3" type="1">
<li>On résout le schéma sur <span class="math inline">\(U\)</span> :</li>
</ol>
<p><span class="math display">\[
    U_i^{n+1} \gets U_i^n - \frac{\Delta t}{\Delta x}(F_{i+\frac{1}{2}}^n - F_{i-\frac{1}{2}}^n)
  \]</span></p>
<ol start="4" type="1">
<li>On calcule les variables intensives <span class="math inline">\((\rho_i^{n+1},u_i^{n+1},T_i^{n+1})\)</span> :</li>
</ol>
<p><span class="math display">\[
    \begin{pmatrix}
      \rho^{n+1}_i \\
      u^{n+1}_i \\
      T^{n+1}_i
    \end{pmatrix}
    =
    \begin{pmatrix}
      U_1             \\
      \frac{U_2}{U_1} \\
      \frac{U_3}{U_1} - \left(\frac{U_2}{U_1}\right)^2
    \end{pmatrix}
  \]</span></p>
<ol start="5" type="1">
<li>On calcule la maxwellienne <span class="math inline">\((\mathcal{M}_{[f^{n+1}]})_{i,k}\)</span> en tout point <span class="math inline">\((i,k)\)</span> de l’espace des phases :</li>
</ol>
<p><span class="math display">\[
    (\mathcal{M}_{[f^{n+1}]})_{i,k} = \frac{\rho_i^{n+1}}{\sqrt{2\pi T^{n+1}_i}}\exp\left(-\frac{1}{2}\frac{|v_k - u_i^{n+1} |^2}{T^{n+1}_i} \right)
  \]</span><a href="#5.1" id="5.1" class="eq"></a></p>
<ol start="6" type="1">
<li>On approxime <span class="math inline">\(f^{n+1}_{i,k}\)</span> via le schéma avec le terme de transport et de diffusion :</li>
</ol>
<p><span class="math display">\[
    f^{n+1}_{i,k} = \frac{1}{1+\frac{\Delta t}{\varepsilon}} \left[ f^n_{i,k} - \frac{\Delta t}{\Delta x}v_k (f^n_{i+\frac{1}{2},k} - f^n_{i-\frac{1}{2},k}) +\frac{\Delta t}{\varepsilon}(\mathcal{M}_{[f^{n+1}]})_{i,k}  \right]
  \]</span></p>
<ol start="7" type="1">
<li>On corrige l’approximation <span class="math inline">\(U_i^{n+1}\)</span> via le calcul du moment de <span class="math inline">\(f^{n+1}_{i,\cdot}\)</span> :</li>
</ol>
<p><span class="math display">\[
    U_i^{n+1} \gets \sum_k m(v_k)f_{i,k}^{n+1} \Delta v
  \]</span></p>
<h3 id="propriété-sur-la-température">Propriété sur la température</h3>
<p>Le calcul de la maxwellienne <span class="math inline">\(\mathcal{M}_{[f^{n}]}\)</span> dans (<a href="#5.1" class="aeq">5.1</a>) nécessite l’extraction de la racine carré de la température <span class="math inline">\((T_i^n)_i\)</span> à tout temps <span class="math inline">\(t^n\)</span>, or celle-ci est uniquement définie par :</p>
<p><span class="math display">\[
  T_i^n = \frac{(U_3)_i^n}{(U_1)_i^n} - \left(\frac{(U_2)_i^n}{(U_1)_i^n}\right)^2
\]</span></p>
<blockquote>
<p>TODO: écrire ceci sous forme de proposition + preuve</p>
</blockquote>
<p>La proposition suivante assure la positivité de cette valeur, condition nécessaire pour assurer la validité des calculs. En utilisant la définition du vecteur <span class="math inline">\(U_i^n\)</span> on peut reformuler <span class="math inline">\(T_i^n\)</span> comme :</p>
<p><span class="math display">\[
  T_i^n = \frac{ \sum_k |v_k|^2f_{i,k}^n\Delta v }{ \sum_k f_{i,k}^n\Delta v } - \left(\frac{ \sum_k v_k f_{i,k}^n\Delta v}{ \sum_k f_{i,k}^n\Delta v }\right)^2
\]</span></p>
<p>Pour que la température reste positive il suffit de vérifier :</p>
<p><span class="math display">\[
  \sum_k |v_k|^2 f_{i,k}^n\Delta v \sum_k f_{i,k}^n\Delta v - \left( \sum_k v_k f_{i,k}^n\Delta v \right)^2 \geq 0
\]</span></p>
<p>Or, en appliquant l’inégalité de Cauchy-Schwarz discrète sur le premier terme avec les fonctions <span class="math inline">\(v_k\sqrt{f_{i,k}^n}\)</span> et <span class="math inline">\(\sqrt{f_{i,k}^n}\)</span> on obtient :</p>
<p><span class="math display">\[
  \sum_k (v_k\sqrt{f_{i,k}^n})^2\Delta v \sum_k (\sqrt{f_{i,k}^n})^2\Delta v \geq \left| \sum_k v_k \sqrt{f_{i,k}^n}\sqrt{f_{i,k}^n} \Delta v \right|^2
\]</span></p>
<p>C’est-à-dire que l’on a bien :</p>
<p><span class="math display">\[
  \sum_k |v_k|^2 f_{i,k}^n \Delta v \sum_k f_{i,k}^n \Delta v \geq \left( \sum_k v_k f_{i,k}^n \Delta v \right)^2
\]</span></p>
<p>Ce qui garantit bien la positivité de <span class="math inline">\(T_i^n\)</span> en tout point <span class="math inline">\(x_i\)</span> de l’espace et pour tout temps <span class="math inline">\(t^n\)</span>.</p>
<h3 id="propriétés-de-conservations">Propriétés de conservations</h3>
<p>Nous allons étudier ce que donnent les propriétés de conservations énoncées dans l’équation (<a href="#2.4" class="aeq">2.4</a>) dans le domaine discret :</p>
<p><span class="math display">\[
  \sum_i U^n_i \Delta x = \sum_i U^0_i \Delta x
\]</span></p>
<p>La première composante de cette somme est la masse du système, la seconde la quantité de mouvement et la troisième l’énergie, trois grandeurs conservatives d’un point de vue physique. Il est donc important de tracer ces valeurs pour vérifier leur conservation par le schéma numérique.</p>
<p>On peut aussi comparer ce résultat à :</p>
<p><span class="math display">\[
  \sum_{i,k} m(v_k)f^n_{i,k} \Delta x \Delta v
\]</span></p>
<p>qui doit être indépendant de <span class="math inline">\(n\)</span> à erreur sur <span class="math inline">\(\sum_k \mathcal{M}_[f]\)</span> près. En effet dans le contexte fluide nous avons :</p>
<p><span class="math display">\[
  \sum_{i,k} m(v_k)f^n_{i,k}\Delta x \Delta v \approx \sum_{i,k} m(v_k)(\mathcal{M}_[f^n])_{i,k}\Delta x \Delta v = \sum_i U^n_i
\]</span></p>
<p>Il est nécessaire d’approximer correctement l’intégrale sur <span class="math inline">\(v \in\mathbb{R}^d\)</span>, numériquement cela se traduit par un <span class="math inline">\(v_{\text{max}}\)</span> suffisamment grand.</p>
<p>On constate bien une conservation de ces valeurs. La légère évolution de ces valeurs est due à la mauvaise approximation de la maxwellienne.</p>
<blockquote>
<p>TODO: insérer ici un graph prouvant ces dires</p>
</blockquote>
<h2 id="discrétisation-du-modèle-micro-macro">Discrétisation du modèle micro-macro</h2>
<p>Nous voulons discrétiser le modèle <em>micro-macro</em> (<a href="#3.4" class="aeq">3.4</a>) en considérant le couple de variables <span class="math inline">\((U_i^n,g_{i,k}^n)\)</span> une approximation de <span class="math inline">\(U(t^n,x_i)\)</span> et <span class="math inline">\(g(t^n,x_i,v_k)\)</span> au temps <span class="math inline">\(t^n = n\Delta t\)</span> avec <span class="math inline">\(\Delta t &gt;0\)</span> le pas de temps, à la position <span class="math inline">\(x_i = i\Delta x\)</span> avec <span class="math inline">\(\Delta x\)</span> le pas d’espace, à la vitesse <span class="math inline">\(v_k = k\Delta v\)</span> avec <span class="math inline">\(\Delta v\)</span> le pas de vitesse.</p>
<h3 id="écriture-de-la-partie-macro">Écriture de la partie <em>macro</em></h3>
<p>La partie <em>macro</em> du modèle est une modification du modèle d’Euler classique (<a href="#2.1" class="aeq">2.1</a>). Nous avons adapté un code de simulation des équations d’Euler, utilisant un flux de Lax-Friedrichs avec un limiteur de pente de van Leer symétrique, comme le schéma de la partie <em>macro</em> de <span class="citation" data-cites="dimarco">[2]</span>. Nous utiliserons donc le schéma suivant :</p>
<p><span class="math display">\[
  U_i^{n+1} = U_i^n - \frac{\Delta t}{\Delta x}(\mathcal{F}_{i+\frac{1}{2}}^n - \mathcal{F}_{i-\frac{1}{2}}^n) - \frac{\Delta t}{2\Delta x}(G_{i+1}^n - G_{i-1}^n)
\]</span></p>
<p>où la grandeur calculée <span class="math inline">\(U_i^n\)</span> est une approximation de <span class="math inline">\(U(t^n,x_i)\)</span> au temps <span class="math inline">\(t^n = n\Delta t\)</span> en <span class="math inline">\(x_i = i\Delta x\)</span>. Le flux <span class="math inline">\(G_{i}^n\)</span> fait le lien avec la partie <em>micro</em> :</p>
<p><span class="math display">\[
  G_i^n = \sum_k v_k m(v_k) g_{i,k}^n \Delta v
\]</span></p>
<p>Le flux numérique <span class="math inline">\(\mathcal{F}_{i+\frac{1}{2}}^n\)</span> donné par :</p>
<p><span class="math display">\[
  \mathcal{F}_{i+\frac{1}{2}}^n = \frac{1}{2}(\mathcal{F}(U^n_{i}) + \mathcal{F}(U^n_{i+1})) -\frac{1}{2}\lambda(U_{i+1}^n - U_i^n)) + \frac{1}{4}(\sigma_i^{n,+} - \sigma_{i+1}^{n,-})
\]</span></p>
<p>où :</p>
<ul>
<li><p><span class="math inline">\(\mathcal{F}\)</span> est la fonction du modèle d’Euler donné par :</p>
<p><span class="math display">\[
  \mathcal{F}:U=\begin{pmatrix}\rho \\ \rho u \\ e\end{pmatrix} \mapsto \mathcal{F}(U) = \begin{pmatrix} \rho u \\ \rho u^2 + p \\ eu + pu \end{pmatrix}
\]</span></p>
où <span class="math inline">\(p=2e-\rho u^2\)</span> est la pression.</li>
<li><p><span class="math inline">\(\sigma_i^{n,\pm}\)</span> est un terme correcteur de second ordre, notons <span class="math inline">\(\eta_i^{n,\pm} = \mathcal{F}(U_i^n)\pm\lambda U_i^n\)</span> :</p>
<p><span class="math display">\[
  \sigma_i^{n,\pm} = ( \eta_i^{n,\pm} - \eta_{i-1}^{n,\pm} )\phi(\chi_i^{n,\pm})
\]</span></p>
<p>avec <span class="math inline">\(\phi\)</span> la fonction de limiteur de pente de van Leer symétrique donnée par :</p>
<p><span class="math display">\[
  \phi:x\mapsto \frac{|x|+x}{1+|x|}
\]</span></p>
<p>fonction que l’on applique à <span class="math inline">\(\chi_i^{n,\pm}\)</span> donné par :
<span class="math display">\[
  \chi_i^{n,\pm} = \frac{\eta_i^{n,\pm} - \eta_{i-1}^{n,\pm}}{\eta_{i+1}^{n,\pm} - \eta_i^{n,\pm}}
\]</span></p></li>
<li><p><span class="math inline">\(\lambda\)</span> est la plus grande valeur propre du système d’Euler.</p></li>
</ul>
<h3 id="écriture-de-la-partie-micro">Écriture de la partie <em>micro</em></h3>
<p>La partie <em>micro</em> (<a href="#3.3" class="aeq">3.3</a>) ne correspond plus simplement au modèle cinétique précédemment étudié. Le projecteur <span class="math inline">\(\Pi\)</span> (<a href="#3.1" class="aeq">3.1</a>) fait intervenir de nouveaux termes.</p>
<p><span class="math display">\[
  g^{n+1} = \frac{1}{1+\frac{\Delta t}{\varepsilon}}\left[ g^n - \Delta t (I\underbrace{-\Pi}_{\text{(a)}})(v\cdot\nabla_x g^n) - \Delta t (I\underbrace{-\Pi}_{\text{(b)}})(v\cdot\nabla_x \mathcal{M}_{[U^{n+1}]}) \right]
\]</span></p>
<p>Ces nouveaux termes <span class="math inline">\(\text{(a)}\)</span> et <span class="math inline">\(\text{(b)}\)</span> nécessitent l’appel du même projecteur <span class="math inline">\(\Pi\)</span>, il est intéressant de les regrouper pour minimiser le temps de calcul :</p>
<p><span class="math display">\[
  g^{n+1} = \frac{1}{1+\frac{\Delta t}{\varepsilon}}\left[ g^n -\Delta t (I-\Pi)(v\cdot\nabla_x(g^n+\mathcal{M}_{[U^{n+1}]}) \right]
\]</span></p>
<p>Ne résulte de cette réécriture qu’une seule dérivée en espace à approximer via les flux numériques d’ordre élevé précédemment présentés.</p>
<p><span class="math display">\[
  g^{n+1}_{i,k} = \frac{1}{1+\frac{\Delta t}{\varepsilon}}\left[ g^n_{i,k} - (I-\Pi)\left(\frac{\Delta t}{\Delta x}v_k(\tilde{f}^n_{i+\frac{1}{2},k} - \tilde{f}^n_{i-\frac{1}{2},k})\right)  \right]
\]</span></p>
<p>où <span class="math inline">\(\tilde{f}^n_{i+\frac{1}{2},k}\)</span> est le flux numérique de <span class="math inline">\(\tilde{f}^n_{i,k} = g^n_{i,k} + (\mathcal{M}_{[U^{n+1}]})_{i,k}\)</span>.</p>
<h3 id="algorithme-général">Algorithme général</h3>
<p>On suppose donné un maillage de l’espace des phases, on suppose <span class="math inline">\(g_{i,k}^n\)</span> et <span class="math inline">\(U_i^n\)</span> donnés par l’itération précédente, le calcul de la nouvelle itération s’effectue schématiquement comme suit :</p>
<ol type="1">
<li>On calcule le flux <span class="math inline">\(G_i^n\)</span> de <span class="math inline">\(g_{i,k}^n\)</span> :</li>
</ol>
<p><span class="math display">\[
    G_i^n \gets \sum_k v_k m(v_k) g_{i,k}^n \Delta v
  \]</span></p>
<p>Ceci permettra d’effectuer une approximation de <span class="math inline">\(\partial_x \langle vm(v)g \rangle\)</span> par <span class="math inline">\(\frac{G_{i+1}^n - G_{i-1}^n}{2\Delta x}\)</span>.</p>
<ol start="2" type="1">
<li>Résolution de la partie <em>macro</em> : <span class="math inline">\(\partial_t U + \partial_x \mathcal{F}(U) + \partial_x\langle vm(v)g \rangle = 0\)</span> avec un schéma de <em>Lax-Friedrichs</em>, nous obtenons ainsi <span class="math inline">\(U^{n+1}_i\,\forall i\)</span>.</li>
</ol>
<p><span class="math display">\[
    U_i^{n+1} \gets U_i^n - \frac{\Delta t}{\Delta x}(\mathcal{F}(U^n)_{i+\frac{1}{2}} - \mathcal{F}(U^n)_{i-\frac{1}{2}}) - \frac{\Delta t}{2\Delta x}(G_{i+1}^n - G_{i-1}^n)
  \]</span></p>
<ol start="3" type="1">
<li>On calcule la maxwellienne via l’incrémentation du vecteur <span class="math inline">\(U^{n+1}\)</span> :</li>
</ol>
<p><span class="math display">\[
    (\mathcal{M}_{[U^{n+1}]})_{i,k} = \frac{\rho^{n+1}_i}{\sqrt{2\pi T^{n+1}_i}} \exp\left(-\frac{1}{2}\frac{ | u^{n+1}_i - v_k |^2 }{T^{n+1}_i}\right)
  \]</span></p>
<ol start="4" type="1">
<li>On calcule les flux numériques d’ordre élevé de <span class="math inline">\(g_{i+\frac{1}{2},k}^n\)</span> et <span class="math inline">\((\mathcal{M}_{[U^{n+1}]})_{i+\frac{1}{2},k}\)</span>, ceci permettra d’approximer les dérivées partielles en espace sur ces termes.</li>
</ol>
<p><span class="math display">\[
    g_{i+\frac{1}{2},k}^n \gets \left( (g_{j,k}^n)_{j\in [\![ i-2;i+2 ]\!] } , v_k \right)
  \]</span><a href="#5.2" id="5.2" class="eq"></a></p>
<ol start="5" type="1">
<li>On incrémente <span class="math inline">\(g_{i,k}^n\)</span> via la partie <em>micro</em> :</li>
</ol>
<p><span class="math display">\[
  \begin{aligned}
    g_{i,k}^{n+1} \gets \frac{1}{1+\frac{\Delta t}{\varepsilon}}\left[\vphantom{\frac{\Delta}{\Delta}} g_{i,k}^n \right. &amp; - (I-\Pi)\left(\frac{\Delta t}{\Delta x}v_k(g_{i+\frac{1}{2},k}^n - g_{i-\frac{1}{2},k}^n)\right) \\
    &amp; \left. - (I-\Pi)\left( \frac{\Delta t}{\Delta x}v_k( (\mathcal{M}_{[U^{n+1}]})_{i+\frac{1}{2},k} - (\mathcal{M}_{[U^{n+1}]})_{i-\frac{1}{2},k})\right) \vphantom{\frac{\Delta}{\Delta}} \right]
  \end{aligned}
  \]</span></p>
<p>Ceci peut se résumer à deux termes de transports projetés selon <span class="math inline">\((I-\Pi)\)</span>. La discrétisation en temps présenté ici utilise une méthode d’Euler implicite ; numériquement nous n’avons pas observé d’instabilité dans le cadre d’un gaz raréfié. La mécanique des plasmas étudie traditionnellement des comportement en temps long, dans ce cas une discrétisation d’ordre plus élevé en temps fut nécessaire pour accompagner l’ordre élevé en espace.</p>
<h3 id="propriétés-du-schéma">Propriétés du schéma</h3>
<p>Dans le modèle continue, la propriété <span class="math inline">\(\Pi(g) = 0\)</span> est assuré par construction de <span class="math inline">\(g\)</span>, à tout instant <span class="math inline">\(t\)</span>. Dans le schéma numérique il faut s’assurer que cette propriété est conserver si <span class="math inline">\(\Pi(g^0) = 0\)</span>. Pour cela nous allons étudier <span class="math inline">\(\Pi(g^{n+1})\)</span> en supposant <span class="math inline">\(\Pi(g^n) = 0\)</span>. Le schéma nous donne :</p>
<p><span class="math display">\[
  \Pi(g^{n+1}) = \frac{1}{1+\frac{\Delta t}{\varepsilon}}\left[ \Pi(g^n) - \Pi\left[(I-\Pi)\left( \frac{\Delta t}{\Delta x}v\partial_x \tilde{f}^n  \right)\right]  \right]
\]</span></p>
<p>où, pour rappel, <span class="math inline">\(\tilde{f}^n = \mathcal{M}_{[f^{n+1}]}+g^n\)</span>. Or <span class="math inline">\((I-\Pi)(v\partial_x \tilde{f}^n)\)</span> appartient au noyau de <span class="math inline">\(\Pi\)</span>, par propriété du l’opérateur de projection nous obtenons donc :</p>
<p><span class="math display">\[
  \Pi(g^{n+1}) = 0
\]</span></p>
<p>D’où la propriété suivante :</p>
<p><span class="math display">\[
  \Pi(g^n) = 0 \Rightarrow \Pi(g^{n+1}) = 0
\]</span></p>
<p>La variable d’entrée de simulation <span class="math inline">\(g^0_{i,k}\)</span> doit donc être initialisée de telle sorte à garantir cette propriété. Dans nos cas tests nous connaissons systématiquement la fonction <span class="math inline">\(f^0_{i,k}\)</span>, il suffit alors d’initialiser <span class="math inline">\(g^0_{i,k}\)</span> à :</p>
<p><span class="math display">\[
  g^0_{i,k} = f^0_{i,k} - (\mathcal{M}_{[f^0]})_{i,k}
\]</span></p>
<h2 id="approximation-du-modèle-micro-macro-avec-htx">Approximation du modèle <em>micro-macro</em> avec <span class="math inline">\(h(t,x)\)</span></h2>
<p>Dans cette partie, nous fixons la dimension du problème à <span class="math inline">\(d=1\)</span>, en effet l’approche que nous avons pu avoir par la suite sur la fonction <span class="math inline">\(h(t,x)\)</span> ne se généralise pas directement au cas <span class="math inline">\(d=2,3\)</span>.</p>
<p>La discrétisation directe du modèle <em>micro</em> avec l’approximation apportée par la fonction <span class="math inline">\(h\)</span> décrit en (<a href="#3.6" class="aeq">3.6</a>) s’écrit comme :</p>
<p><span class="math display">\[
  \begin{aligned}
    g_{i,k}^{n+1} \gets \frac{1}{1+\frac{\Delta t}{\varepsilon}}\left[\vphantom{\frac{\Delta}{\Delta}} g_{i,k}^n \right. &amp; - h_i^n(I-\Pi)\left(\frac{\Delta t}{\Delta x}v_k(g_{i+\frac{1}{2},k}^n - g_{i-\frac{1}{2},k}^n)\right) \\
    &amp; \left. - h_i^n(I-\Pi)\left( \frac{\Delta t}{\Delta x}v_k( (\mathcal{M}_{[U^{n+1}]})_{i+\frac{1}{2},k} - (\mathcal{M}_{[U^{n+1}]})_{i-\frac{1}{2},k})\right) \right. \\
    &amp; \left. \vphantom{\frac{\Delta}{\Delta}} + \frac{g_{i,k}^n}{h_i^n}\partial_t h_i^n \right]
  \end{aligned}
\]</span><a href="#5.3" id="5.3" class="eq"></a></p>
<p>où <span class="math inline">\(h_i^n\)</span> est une approximation de <span class="math inline">\(h(t^n,x_i)\)</span></p>
<p>L’approche proposée dans <span class="citation" data-cites="dimarco">[2]</span> est de calculer la fonction <span class="math inline">\(h(t,x)\)</span> à partir du moment de la fonction <span class="math inline">\(g\)</span>, c’est-à-dire à partir de <span class="math inline">\(\langle m(v_k)g_{i,k}^n\rangle_v\)</span>. Cette méthode de calcul de la fonction <span class="math inline">\(h\)</span> nécessite le parcours de l’ensemble du domaine à l’itération <span class="math inline">\(t^n\)</span> ; une approche similaire est utilisée dans <span class="citation" data-cites="filbet">[3]</span> avec le calcul des cellules du milieu hydrodynamique ou cinétique en fonction d’un critère évalué à chaque itération. Cette méthode fonctionne très bien en théorie mais ne permet pas de réduire le temps de calcul en ne parcourant, à l’itération <span class="math inline">\(t^n\)</span>, que le support de <span class="math inline">\(h(t^n,\cdot)\)</span>. Nous avons opté ici pour une technique nécessitant une connaissance en amont des zones de chocs et du parcours de l’onde de choc, c’est-à-dire une connaissance <em>a priori</em> de <span class="math inline">\(\Omega_K(t)\)</span>.</p>
<p>Dans un premier temps, pour étudier la dynamique et les conséquences d’une fonction indicatrice nous nous sommes restreints à une fonction <span class="math inline">\(h\)</span> constante au cours du temps, et avons testé différent profils : fonction porte ou trapézoïdale. Cela a permis de mettre au point la résolution de la partie <em>micro</em> uniquement sur le sous-domaine <span class="math inline">\(\Omega_K\)</span>. Algorithmiquement cela se traduit par l’introduction de deux variables <span class="math inline">\(x_s\)</span> et <span class="math inline">\(x_e\)</span> (<span class="math inline">\(s\)</span> pour <em>start</em> et <span class="math inline">\(e\)</span> pour <em>end</em>) telles que :</p>
<p><span class="math display">\[
  \Omega_K \subset [x_s,x_e]
\]</span></p>
<p>Nous définissons 2 indices <span class="math inline">\(i_s\)</span> et <span class="math inline">\(i_e\)</span> tels que <span class="math inline">\(x_s = i_s\Delta x\)</span> et <span class="math inline">\(x_e = i_e \Delta x\)</span>. Le schéma sur <span class="math inline">\(g\)</span> se définit comme :</p>
<p><span class="math display">\[
  g_{i,k}^n \gets \begin{cases}
    \hat{g}_{i,k}^n  &amp; \text{si } i\in [\![ i_s , i_e  ]\!] \\
    0                &amp; \text{sinon}
  \end{cases}
\]</span></p>
<p>où <span class="math inline">\(\hat{g}_{i,k}^n\)</span> est la grandeur calculée par (<a href="#5.3" class="aeq">5.3</a>). Une fois cette technique mise au point il a suffit de trouver, de manière empirique, deux fonctions <span class="math inline">\(x_s:t\mapsto x_s(t)\)</span> et <span class="math inline">\(x_e:t\mapsto x_e(t)\)</span> s’adaptant correctement aux conditions initiales simulées.</p>
<h3 id="h-une-fonction-porte"><span class="math inline">\(h\)</span> une fonction porte</h3>
<p>Dans un premier temps nous allons considérer une fonction <span class="math inline">\(h\)</span> continument dérivable mais dont les variations s’effectuent sur un intervalle de longueur inférieure à <span class="math inline">\(\Delta x\)</span>, <span class="math inline">\(h\)</span> se résume donc à une fonction porte :</p>
<p><span class="math display">\[
  h_i = \begin{cases}
    0 &amp;  \textrm{, si}\ x_i &lt; x_s \\
    1 &amp;  \textrm{, si}\ x_s \leq x_i \leq x_e \\
    0 &amp;  \textrm{, si}\ x_i &gt; x_e \\
    \end{cases}
\]</span><a href="#5.4" id="5.4" class="eq"></a></p>
<blockquote>
<p>TODO: mettre 2 cas tests, 1 avec <span class="math inline">\(h\)</span> trop petit (apparition d’oscillations parasites à la fonction du domaine), et un autre où tout se passe bien (domaine plus large)</p>
</blockquote>
<p>Le risque de la mauvaise anticipation du domaine <span class="math inline">\(\Omega_K\)</span> est que celui-ci déborde du support de <span class="math inline">\(h\)</span>. Numériquement ce risque se traduit par l’apparition d’oscillations dues à une discontinuité de <span class="math inline">\(g\)</span> aux bords du support de <span class="math inline">\(h\)</span>.</p>
<h3 id="h-une-fonction-trapèze"><span class="math inline">\(h\)</span> une fonction trapèze</h3>
<p>Considérons maintenant une fonction <span class="math inline">\(h\)</span> définie comme suit :</p>
<p><span class="math display">\[
  h_i = \begin{cases}
    0                                               &amp; \textrm{, si\ }           x_i &lt; x_s     \\
     \frac{1}{x_s^*-x_s} x - \frac{x_s}{x_s^*-x_s}  &amp; \textrm{, si\ } x_s     &lt; x_i &lt; x_s^{*} \\ 
    1                                               &amp; \textrm{, si\ } x_s^{*} &lt; x_i &lt; x_e^{*} \\
    -\frac{1}{x_e-x_e^*} x + \frac{x_e}{x_e-x_e^* } &amp; \textrm{, si\ } x_e^{*} &lt; x_i &lt; x_e     \\
    0                                               &amp; \textrm{, si\ } x_e     &lt; x_i           \\
  \end{cases}
\]</span></p>
<p>Pour les différents tests sur une telle fonction on conservera toujours les valeurs de <span class="math inline">\(x_s\)</span> et <span class="math inline">\(x_e\)</span> identiques au cas test de la fonction porte, nous allons donc jouer sur les valeurs de <span class="math inline">\(x_s^*\)</span> et <span class="math inline">\(x_e^*\)</span>. On choisit généralement <span class="math inline">\(x_s^*\)</span> et <span class="math inline">\(x_e^*\)</span> de façon symétrique c’est-à-dire :</p>
<p><span class="math display">\[
  x_s^* = x_s + \delta x \qquad x_e^* = x_e - \delta x
\]</span></p>
<p>On obtient ainsi dans les cas extrêmes une fonction porte pour <span class="math inline">\(\delta x = 0\)</span> ou une fonction chapeau pour <span class="math inline">\(\delta x = \frac{x_e-x_s}{2}\)</span>.</p>
<blockquote>
<p>TODO: cas d’une fonction chapeau et une ou deux fonctions trapézoïdales</p>
</blockquote>
<h3 id="htx-une-fonction-dépendant-du-temps"><span class="math inline">\(h(t,x)\)</span> une fonction dépendant du temps</h3>
<p>Maintenant essayons de faire évoluer <span class="math inline">\(h\)</span> en fonction du temps. Comme nous l’avons écrit précédemment il est possible d’utiliser la troisième composante du flux cinétique de <span class="math inline">\(g\)</span>, comme dans <span class="citation" data-cites="dimarco">[2]</span>. Ceci implique de calculer <span class="math inline">\(g\)</span> en tout point de l’espace, ce que l’introduction de la fonction <span class="math inline">\(h\)</span> nous permet en principe d’éviter. En effet, l’introduction de la fonction <span class="math inline">\(h\)</span> permet, dans la partie <em>micro</em>, plus coûteuse en temps de calcul que la partie <em>macro</em>, de ne parcourir l’espace qu’entre les valeurs <span class="math inline">\(x_s\)</span> et <span class="math inline">\(x_e\)</span>.</p>
<p>Une autre méthode utilisée dans <span class="citation" data-cites="filbet">[3]</span>, est de déterminer dans chaque cellule, à chaque itération, le modèle prédominant entre fluide et cinétique. Cela demande de l’évaluation systématique d’un critère, potentiellement coûteux en temps de calcul, pour éventuellement échanger le modèle prédominant dans chaque cellule. L’inconvénient de ce type d’approche est le calcul de dérivées à la jonction entre deux modèles. Le nombre restreint de cellules où le modèle cinétique est effectivement évaluée permet en principe de réduire globalement le temps de simulation.</p>
<p>À l’inverse des approches présentées dans <span class="citation" data-cites="dimarco">[2]</span> et <span class="citation" data-cites="filbet">[3]</span>, nous avons besoin d’une connaissance amont du problème. Pour ce faire nous allons étudier la troisième composante du flux cinétique de <span class="math inline">\(g\)</span> dans sa globalité, sans fonction <span class="math inline">\(h\)</span>, seule composante non nulle du flux cinétique en théorie par la définition de <span class="math inline">\(g\)</span> comme étant à moyenne nulle en <span class="math inline">\(v\)</span>. Ce flux (respectivement le logarithme de ce flux) est représenté en figure TODO (respectivement en figure TODO).</p>
<div>
<figure>
<img src="img/mimas_test/h_t/fluxg.png" alt="Flux numérique de g" /><figcaption>Flux numérique de <span class="math inline">\(g\)</span></figcaption>
</figure>
<figure>
<img src="img/mimas_test/h_t/fluxg_log.png" alt="Logarithme du flux numérique de g" /><figcaption>Logarithme du flux numérique de <span class="math inline">\(g\)</span></figcaption>
</figure>
<p>Visualisation de la troisième composante du flux cinétique de <span class="math inline">\(g\)</span> en fin de simulation</p>
</div>
<p>Contrairement à ce qui était attendue le flux ne diminue pas suffisamment pour le contraindre dans une région. Le seuil que nous allons utilisé est <span class="math inline">\(10^{-15}\)</span>, ce qui peut correspondre à la sortie du bruit numérique de la précision du zéro machine ; un seuil plus petit, au alentour de <span class="math inline">\(10^{-17}\)</span> est facilement envisageable et sans doute plus juste, mais cela se fait au détriment du temps de calcul.</p>
<figure>
<img src="img/mimas_test/h_t/xsxe.png" alt="Évolution de x_s et x_e au cours du temps" /><figcaption>Évolution de <span class="math inline">\(x_s\)</span> et <span class="math inline">\(x_e\)</span> au cours du temps</figcaption>
</figure>
<p>Sur cette courbe, <span class="math inline">\(x_s\)</span> correspond au premier dépassement du seuil, et <span class="math inline">\(x_e\)</span> au dernier ; sont aussi représentés les grandeurs de <span class="math inline">\(x_s\)</span> et <span class="math inline">\(x_e\)</span> précédemment choisis dans le cas d’une fonction porte.</p>
<p>Nous souhaitons que <span class="math inline">\(h(t,x)\)</span> enveloppe la zone où <span class="math inline">\(\langle v_k^3g_{i,k}^n\rangle_v &gt; 10^{-15}\)</span>, pour cela nous considérons deux fonctions <span class="math inline">\(x_s^n\)</span> et <span class="math inline">\(x_e^n\)</span> donnant au cours du temps le domaine cinétique. Cette démarche ne fonctionne pas pour un système périodique c’est pour cela que nous sommes restés avec des conditions aux bords de Neumann. L’approche dans <span class="citation" data-cites="filbet">[3]</span> ne permet pas de diminuer la taille du domaine à parcourir au cours du temps ; en revanche elle propose, dans le cas d’une solution régulière, d’avoir un libre parcours moyen dépendant de <span class="math inline">\(x\)</span>, cela permet d’effectuer une transition plus douce entre un modèle cinétique et fluide.</p>
<h2 id="tests-numériques-dans-le-cas-de-gaz-raréfiés">Tests numériques dans le cas de gaz raréfiés</h2>
<p>Dans cette section, nous allons présenter différent résultats numériques et comparer les performances du modèle <em>micro-macro</em>, dans le contexte d’un gaz raréfiés c’est-à-dire en l’absence de champ électrique <span class="math inline">\(E\)</span> et dans un régime proche d’un fluide <span class="math inline">\(\varepsilon \to 0\)</span>. Plusieurs cas tests de la littératures ont été utilisés pour démontrer la versatilité de la modélisation.</p>
<h3 id="conditions-aux-bords-périodiques">Conditions aux bords périodiques</h3>
<p>Le premier cas test que nous considérons est un domaine <span class="math inline">\(\Omega\)</span> périodique avec pour condition intiale la fonction de densité suivante :</p>
<p><span class="math display">\[
  f(t=0,x,v) = \frac{1}{\sqrt{2\pi}}(1 - \alpha\cos(k_x x))\text{e}^{-\frac{|v|^2}{2}}
\]</span><a href="#5.5" id="5.5" class="eq"></a></p>
<p>avec les paramètres <span class="math inline">\(\alpha\)</span> et <span class="math inline">\(k_x\)</span> représentent respectivement la perturbation initiale et le nombre d’onde. Le domaine <span class="math inline">\(\Omega\)</span> est défini par <span class="math inline">\(\Omega = [0,\frac{2\pi}{k_x}]\)</span> pour assurer une période en <span class="math inline">\(x\)</span> de la condition initiale. La condition périodique se traduit par <span class="math inline">\(f(t,0,v)=f(t,\frac{2\pi}{k_x},v)\)</span> à tout instant <span class="math inline">\(t\)</span> pour tout <span class="math inline">\(v\)</span>. Le domaine en <span class="math inline">\(v\)</span> est en théorie infini, numériquement il sera borné et inclu dans l’intervalle <span class="math inline">\([-v_{\text{max}},v_{\text{max}}]\)</span>, avec <span class="math inline">\(v_{\text{max}}\)</span> pris suffisament grand pour que <span class="math inline">\(f(t,x,v_{\text{max}})\approx 0\)</span>, avec une dérivée nulle (fin de queue d’une gaussienne). L’héritage des tests en 2D sur le schéma WENO nous a conduit à conserver des conditions aux bords périodiques en <span class="math inline">\(v\)</span>. De premiers tests ont été conduit en 1D avec des conditions aux bords de Neumann sans aucune différence numérique notable.</p>
<p>Nous allons comparer les résultats avec un code de simulation des équations d’Euler qui servira de référence. Il est donc nécessaire de traduire la condition (<a href="#5.5" class="aeq">5.5</a>) dans le domaine macroscopique :</p>
<blockquote>
<p>TODO: vérifier cette condition initiale (surtout la température)</p>
</blockquote>
<p><span class="math display">\[
  U(t=0,x) = \begin{pmatrix} 1-\alpha\cos(k_x x) \\ 0 \\ \frac{1}{2}(1-\alpha\cos(k_x x)) \end{pmatrix}
\]</span></p>
<p>Les paramètres de simulation sont :</p>
<ul>
<li>Temps final <span class="math inline">\(T_f = 10\)</span></li>
<li>Nombre de points <strong>ça dépend des cas, revoir la valeur de ce paramètre</strong></li>
<li>Perturbation <span class="math inline">\(\alpha = \frac{1}{2}\)</span></li>
<li>Nombre d’onde <span class="math inline">\(k_x - \frac{1}{2}\)</span></li>
<li>Nombre de Knidsen <span class="math inline">\(\varepsilon = 10^{-3}\)</span></li>
</ul>
<p>Le domaine périodique est <span class="math inline">\(\Omega = [0,4\pi]\)</span>.</p>
<blockquote>
<p>TODO: revoir les valeurs de <span class="math inline">\(\Delta x\)</span> et <span class="math inline">\(\Delta v\)</span> (ou plus exactement le nombre de points et la valeur de <span class="math inline">\(v_{\text{max}}\)</span>)</p>
</blockquote>
<p>Conformément au calcul de condition CFL effectué en (TODO mettre numéro de section), nous n’avons pas de contrainte numérique sur le pas de temps <span class="math inline">\(\Delta t\)</span>, puisque nous nous plaçons en régime fluide.</p>
<h3 id="condition-aux-bords-de-neumann">Condition aux bords de Neumann</h3>
<p>Le second cas test abondant dans la litérature est le tube à choc de Sob. La condition initiale est une instabilité conduisant à un choc, le temps de simulation est suffisamment cours pour ne pas étudier le contact de l’onde de choc sur les bords. Le tube est modélisé par un domaine <span class="math inline">\(\Omega = [0,1]\)</span>. Les conditions aux bords sont modélisées par des conditions de Neumann, c’est-à-dire <span class="math inline">\(\partial_x f(t,0,v) = \partial_x f(t,1,v) = 0\)</span> à tout instant <span class="math inline">\(t\)</span> pour toute vitesse <span class="math inline">\(v\)</span>. Comme pour le cas test précédent, le domaine en <span class="math inline">\(v\)</span>, théoriquement égal à <span class="math inline">\(\mathbb{R}\)</span>, est numériquement restreint à l’intervalle <span class="math inline">\([-v_{\text{max}},v_{\text{max}}]\)</span>, avec <span class="math inline">\(v_{\text{max}}\)</span> pris suffisament grand, et avec des conditions au bords périodiques.</p>
<p>La simulation est initialisée par la condition initiale :</p>
<p><span class="math display">\[
  U(t=0,x) = \begin{cases}
    U_L = (\rho_L,u_L,T_L) = (1,0,1) \quad &amp; , x \leq \frac{1}{2} \\
    U_R = (0.125,0,0.8)                    &amp; , x &gt; \frac{1}{2}
  \end{cases}
\]</span></p>
<blockquote>
<p>TODO: mettre une figure de la condition initiale</p>
</blockquote>
<p>Pour initialiser la simulation du modèle cinétique ou la partie <em>micro</em> du modèle <em>micro-macro</em> nous utilisons la maxwellienne de cette condition initiale :</p>
<p><span class="math display">\[
  f(t=0,x,v) = \mathcal{M}_{[U(t=0,x)]}
\]</span></p>
<blockquote>
<p>TODO: est-il nécessaire d’écrire explicitement la valeur de la maxwellienne alors que <span class="math inline">\((\rho,u,T)_{R|L}\)</span> ont déjà été indiqué ?</p>
</blockquote>
<p>Les paramètres de simulations sont :</p>
<ul>
<li>Temps final de simulation <span class="math inline">\(T_f = 0.67\)</span></li>
<li>Nombre de points <strong>ça dépend des cas, revoir la valeur de ce paramètre</strong></li>
<li>Nombre de Knidsen <span class="math inline">\(\varepsilon = 10^{-3}\)</span></li>
</ul>
<p>Le pas de temps <span class="math inline">\(\Delta t\)</span> peut de nouveau être choisi indépendament de <span class="math inline">\(\Delta x\)</span> conformément au calcul de la conditon CFL puisque nous nous plaçons en régime fluide.</p>
<h3 id="milieu-non-homogène-varepsilon-varepsilonx">Milieu non homogène : <span class="math inline">\(\varepsilon = \varepsilon(x)\)</span></h3>
<p>Pour obtenir une description d’un milieu non-homogène, il est possible dans le modèle cinétique de faire évoluer le nombre de Knidsen (paramètre <span class="math inline">\(\varepsilon\)</span>) en fonction de la position : <span class="math inline">\(\varepsilon = \varepsilon(x)\)</span>. Le modèle macroscopique ne permet pas de décrire ce cas et ne sera donc pas utilisé. Ce cas test est proposé dans <span class="citation" data-cites="filbet">[3]</span>, nous reprendrons la même condition initiale :</p>
<p><span class="math display">\[
  f(t=0,x,v) = \frac{1}{2}(\mathcal{M}_{[(\rho,u,T)]} + \mathcal{M}_{[\rho,-u,T]})
\]</span></p>
<p>avec le vecteur <span class="math inline">\((\rho,u,T)\)</span> défini par :</p>
<p><span class="math display">\[
  (\rho(x),u(x),T(x)) = \left( 1+\frac{1}{2}\sin(\pi x) , \frac{3}{4} , \frac{5+2\cos(2\pi x)}{20}  \right)
\]</span></p>
<p>dans le domaine <span class="math inline">\(\Omega = [-\frac{1}{2},\frac{1}{2}]\)</span> et <span class="math inline">\(v\in[-v_{\text{max}},v_{\text{max}}]\)</span>. Le nombre de Knidsen est défini par :</p>
<p><span class="math display">\[
  \varepsilon(x) = 10^{-4} + \frac{1}{2}(\text{arctan}(1+30x) + \text{arctan}(1-30x))
\]</span></p>
<p>Il n’est malheureusement pas possible de comparer les résultats de nos simulations avec les résultats de <span class="citation" data-cites="filbet">[3]</span>. En effet les auteurs y utilisent une vitesse vivant dans <span class="math inline">\(\mathbb{R}^2\)</span>, la définition de la maxwellienne change et avec celle des grandeurs macroscopiques. Par conséquent nous allons comparer les résultats de entre la simulation du modèle cinétique, utilisée alors comme référence, et celle du modèle <em>micro-macro</em>.</p>
<h3 id="fonction-indicatrice-h">Fonction indicatrice <span class="math inline">\(h\)</span></h3>
<blockquote>
<p>TODO: mettre ici un cas où <span class="math inline">\(h\)</span> provoque des oscillations (trop petit), et des cas où ça marche bien</p>
</blockquote>
<p>L’implémentation que nous avons pu faire de la fonction indicatrice <span class="math inline">\(h\)</span>, décrite dans la section (TODO rajouter le numéro de la section), ne fonctionne pas dans le cas de conditions aux bords périodiques. Nous reprennons pour ces tests le cas du tube de Sob avec des condtions aux bords de Neumann. Plusieurs gabarits de fonction <span class="math inline">\(h\)</span> ont été testés, décrits dans la section (TODO rajouter le numéro de la section).</p>
<blockquote>
<p>TODO: reprécisier ici les paramètres de la simu (même s’il s’agit du même tube de Sob que précédemment),</p>
</blockquote>
<h4 id="h-une-fonction-porte-1"><span class="math inline">\(h\)</span> une fonction porte</h4>
<p>Le premier exemple est une fonction porte définie en (<a href="#5.4" class="aeq">5.4</a>). Il s’agit plus d’un démonstrateur technique qu’un test intéressant numériquement. Il permet aussi d’étudier les limites de la méthode avec l’introduction d’une fonction porte trop <em>étroite</em> pour la simulation, c’est-à-dire, en réutilisant les notation de la section (TODO rajouter ici le numéro de la section) :</p>
<p><span class="math display">\[
  [x_s,x_e] \subset \Omega
\]</span></p>
<blockquote>
<p>TODO: indiquer les valeurs de <span class="math inline">\(x_s\)</span> et <span class="math inline">\(x_e\)</span> utilisées</p>
</blockquote>
<h4 id="h-une-fonction-trapèze-1"><span class="math inline">\(h\)</span> une fonction trapèze</h4>
<p>L’utilisation d’une fonction trapèze permet d’obtenir une transition plus douce entre les sous-domaines <span class="math inline">\(\Omega_K\)</span> et <span class="math inline">\(\Omega_F\)</span>, bien que rien de l’impose dans le modèle. L’approche locale utilisée dans <span class="citation" data-cites="dimarco">[2]</span> mène à une fonction <span class="math inline">\(h\)</span> en escalier.</p>
<p>La transition progressive entre <span class="math inline">\(\Omega_K\)</span> et <span class="math inline">\(\Omega_F\)</span> permet de se prémunir d’une part des oscillations dues à une mauvaise étude amont du problème. Cela ne garanti pas la validité des résultats.</p>
<blockquote>
<p>TODO: indiquer les valeurs de <span class="math inline">\(x_s\)</span> et <span class="math inline">\(x_e\)</span> utilisées, ainsi que <span class="math inline">\(\delta x\)</span></p>
</blockquote>
<h4 id="htx-une-fonction-dépendant-du-temps-1"><span class="math inline">\(h(t,x)\)</span> une fonction dépendant du temps</h4>
<p>Dans le cas du tube à chocs de Sob, l’onde de choc se propage depuis le centre du domaine en s’étendant. Il n’est donc pas nécessaire d’évaluer le modèle cinétique sur tout le domaine <span class="math inline">\(\Omega_K\)</span> précédemment utilisé. Il est aussi possible de construire des cas tests où une fonction indicatrice <span class="math inline">\(h\)</span> indépendante du temps impose de simuler la partie <em>micro</em> sur tout le domaine, c’est le cas par exemple du cas test aux conditions aux bords périodiques.</p>
<p>La construction de notre fonction <span class="math inline">\(h\)</span> dépendante du temps s’est faite <em>a posteriori</em>. Elle a nécessité une première étude du cas test sur tout le domaine, avec éventuellement un maillage plus grossier. Aucune procédure d’automatisation d’obtention de cette fonction n’a été envisagée, autre que celles que nous avons pu évoquer dans la littérature, qui ne mène à une fonction discontinue.</p>
<blockquote>
<p>TODO: indiquer les fonctions <span class="math inline">\(x_s:t\mapsto x_s(t)\)</span> et <span class="math inline">\(x_e:t\mapsto x_e(t)\)</span> utilisées, et le choix du <span class="math inline">\(\delta x\)</span> choisi.</p>
</blockquote>
<h1 id="application-pour-les-plasma">Application pour les plasma</h1>
<blockquote>
<p>C’est dans cette partie qu’on a vraiment besoin des tests 2D et qu’on introduit un champ électrique</p>
</blockquote>
<h2 id="modèle-cinétique-1">Modèle cinétique</h2>
<blockquote>
<p>Programme de référence, présentation un peu plus rapide avec l’ajout du terme de champ électrique. Préciser la nécessité numériquement d’introduire RK3 pour l’ordre élevé en espace, avec recalcule de l’équation de Poisson sur chaque étape du RK3.</p>
</blockquote>
<h2 id="modèle-micro-macro">Modèle <em>micro-macro</em></h2>
<blockquote>
<p>Modèle hybride basé sur le modèle cinétique, donc comparatif aux résultats précédents, précision de l’ajout dans la partie <em>micro</em> et <em>macro</em> du champ électrique. Pour le moment RK3 ne fonctionne pas (<em>a priori</em> la Maxwellienne ne reste pas constante sur chaque étape de RK3 donc obligé de recalculer <span class="math inline">\(u\)</span>, et <span class="math inline">\(T\)</span>, pas uniquement <span class="math inline">\(\rho\)</span>, et même ainsi j’ai encore des instabilités).</p>
</blockquote>
<blockquote>
<p>Introduction de <span class="math inline">\(h(t,x)\)</span></p>
</blockquote>
<h2 id="tests-numériques-dans-le-cas-de-plasmas">Tests numériques dans le cas de plasmas</h2>
<h3 id="double-beam">Double beam</h3>
<h3 id="landau">Landau</h3>
<h1 id="liste-des-figures-à-refaire">Liste des figures à refaire</h1>
<p>Pour chaque simulation conserver les paramètres de simulation : entrée, <span class="math inline">\(\varepsilon\)</span>, <span class="math inline">\(\Delta x\)</span>, <span class="math inline">\(\Delta v\)</span>, <span class="math inline">\(\Delta t\)</span>, <span class="math inline">\(nx\)</span>, <span class="math inline">\(nv\)</span>, <span class="math inline">\(T_f\)</span></p>
<ul>
<li>Ordre en 1D et 2D :
<ul>
<li>WENO</li>
<li>Schéma compact</li>
</ul></li>
<li>Simulation cinétique et micro-macro des cas tests usuels sans champ électrique, comparatif entre les schémas du terme de transport :
<ul>
<li>périodique</li>
<li>Neumann (tube de Sob)</li>
</ul></li>
<li>Simulation cinétique et micro-macro avec <span class="math inline">\(\varepsilon(x_i)\)</span></li>
<li>Simulation cas Neumann avec <span class="math inline">\(h(t,x)\)</span>
<ul>
<li>Pour justifier le <span class="math inline">\(h(t,x)\)</span> tracer des coupes du cas Neumann : <span class="math inline">\(f(t_f,x=\{2,7,10\},v)\)</span> et voir une maxwellienne dans le cas fluide et une maxwellienne plus une perturbation dans le cas cinétique (proche du choc)</li>
</ul></li>
<li>Évolution de la masse au cours du temps sur un cas simple (pour prouver que cela a été vérifié)</li>
<li>tester WENO en temps long sur la rotation d’une gaussienne avec Euler et RK3 (apparition d’une trainée)</li>
<li>Cas tests de viscosité (rotation d’un <em>pacman</em>)</li>
<li><span class="math inline">\(log||E||_2 = f(t)\)</span> sur plusieurs cas tests</li>
</ul>
<div id="refs" class="references">
<div id="ref-BENNOUNE20083781">
<p>1. Bennoune, M., Lemou, M., &amp; Mieussens, L. (2008). Uniformly stable numerical schemes for the boltzmann equation preserving the compressible navier–stokes asymptotics. <em>Journal of Computational Physics</em>, <em>227</em>(8), 3781–3803. doi:<a href="https://doi.org/https://doi.org/10.1016/j.jcp.2007.11.032">https://doi.org/10.1016/j.jcp.2007.11.032</a></p>
</div>
<div id="ref-dimarco">
<p>2. Degond, P., Dimarco, G., &amp; Mieussens, L. (2010). A multiscale kinetic–fluid solver with dynamic localization of kinetic effects. <em>Journal of Computational Physics</em>, <em>229</em>(13), 4907–4933. doi:<a href="https://doi.org/10.1016/j.jcp.2010.03.009">10.1016/j.jcp.2010.03.009</a></p>
</div>
<div id="ref-filbet">
<p>3. Filbet, F., &amp; Rey, T. (2015). A hierarchy of hybrid numerical methods for multiscale kinetic equations. <em>SIAM Journal on Scientific Computing</em>, <em>37</em>(3), A1218–A1247. doi:<a href="https://doi.org/10.1137/140958773">10.1137/140958773</a></p>
</div>
<div id="ref-crestetto">
<p>4. Crestetto, A., Crouseilles, N., &amp; Lemou, M. (2012). Kinetic/fluid micro-macro numerical schemes for Vlasov-Poisson-BGK equation using particles. <em>Kinetic and Related Models</em>, <em>5</em>(4), 787–816. doi:<a href="https://doi.org/10.3934/krm.2012.5.787">10.3934/krm.2012.5.787</a></p>
</div>
<div id="ref-ssp_rk3">
<p>5. Shu, C.-W. (2001). A survey of strong stability preserving high order time discretizations.</p>
</div>
<div id="ref-Boyer:2014aa">
<p>6. Boyer, F. (2014). Aspects théoriques et numériques de l’équation de transport.</p>
</div>
<div id="ref-despres">
<p>7. Després, B. (2009). Uniform asymptotic stability of strang’s explicit compact schemes for linear advection. <em>SIAM Journal on Numerical Analysis</em>, <em>47</em>(5), 3956–3976. doi:<a href="https://doi.org/10.1137/080734571">10.1137/080734571</a></p>
</div>
<div id="ref-siam2013">
<p>8. Charles, F., Després, B., &amp; Mehrenberger, M. (2013). Enhanced convergence estimates for semi-lagrangian schemes application to the vlasov–poisson equation. <em>SIAM Journal on Numerical Analysis</em>, <em>51</em>(2), 840–863. doi:<a href="https://doi.org/10.1137/110851511">10.1137/110851511</a></p>
</div>
<div id="ref-icase">
<p>9. Shu, C.-W. (1997). <em>Essentially non-oscillatory and weighted essentially non-oscillatory schemes for hyperbolic conservation laws</em>. Institute for Computer Applications in Science; Engineering (ICASE).</p>
</div>
<div id="ref-weno">
<p>10. Shu, C.-W. (2003). High-order finite difference and finite volume weno schemes and discontinuous galerkin methods for cfd. <em>International Journal of Computational Fluid Dynamics</em>, <em>17</em>(2), 107–118. doi:<a href="https://doi.org/10.1080/1061856031000104851">10.1080/1061856031000104851</a></p>
</div>
<div id="ref-qiu">
<p>11. Qiu, J.-M., Shu, C.-W., Liu, J.-R., &amp; Fang, L.-Z. (2008). A weno algorithm for the growth of ionized regions at the reionization epoch. <em>New Astronomy</em>, <em>13</em>(1), 1–11. doi:<a href="https://doi.org/10.1016/j.newast.2007.06.002">10.1016/j.newast.2007.06.002</a></p>
</div>
<div id="ref-qiu2011">
<p>12. Qiu, J.-M., &amp; Shu, C.-W. (2011). Conservative high order semi-lagrangian finite difference weno methods for advection in incompressible flow. <em>Journal of Computational Physics</em>, <em>230</em>(4), 863–889. doi:<a href="https://doi.org/10.1016/j.jcp.2010.04.037">10.1016/j.jcp.2010.04.037</a></p>
</div>
<div id="ref-weno_time">
<p>13. Wang, R., &amp; Spiteri, R. (2007). Linear instability of the fifth-order weno method. <em>SIAM Journal on Numerical Analysis</em>, <em>45</em>(5), 1871–1901. doi:<a href="https://doi.org/10.1137/050637868">10.1137/050637868</a></p>
</div>
<div id="ref-anm1966">
<p>14. Isaacson, E., &amp; Keller, H. B. (1966). <em>Analysis of numerical methods</em>. John Wiley &amp; Sons Inc. Retrieved from <a href="http://catalogmat.math.univ-rennes1.fr:8080/Record.htm?idlist=3&amp;record=19295946124910131289" class="uri">http://catalogmat.math.univ-rennes1.fr:8080/Record.htm?idlist=3&amp;record=19295946124910131289</a></p>
</div>
<div id="ref-siam1967">
<p>15. Lawson, J. (1967). An order six runge-kutta process with extended region of stability. <em>SIAM Journal on Numerical Analysis</em>, <em>4</em>(4), 620–625. doi:<a href="https://doi.org/10.1137/0704056">10.1137/0704056</a></p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p><span class="math inline">\(\varepsilon=\frac{\ell}{L}\)</span> avec <span class="math inline">\(\ell\)</span> le libre parcours moyen, c’est-à-dire la distance moyenne parcourue par une particule avant interaction entre particules, et <span class="math inline">\(L\)</span> une longueur caractéristique du problème. <span class="math inline">\(\varepsilon\)</span> permet de passer du régime fluide (<span class="math inline">\(\varepsilon =1\)</span>) au régime fluide (<span class="math inline">\(\varepsilon\to 0\)</span>).<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>
<!--<footer id="end" >
  <ul>
    <li>Josselin Massot</li>
    <li><a href="https://irmar.univ-rennes1.fr/" >IRMAR</a></li>
    <li><a href="https://www.univ-rennes1.fr" >Université de Rennes 1</a></li>
    <li><a href="https://www.inria.fr/centre/rennes" >INRIA</a></li>
    <li><a href="http://www.dr17.cnrs.fr/" >CNRS</a></li>
    <!- ->
    <li><a href="https://hostux.fr/" style="text-decoration: none;"><img style="background-color: rgb(255, 255, 255);" src="https://hostux.fr//static/images/bannieres/verticale.png" alt="Un site hébergé par Hostux.fr, hébergeur à prix libre, hébergeur de services Internet à prix libre" height="20px" >Hébergé par Hostux.fr</a></li>
     <!- ->
  </ul>
  <a href="#top" style="display:inline-block; position: absolute; right: 1rem; margin-top: -2.7rem; font-size: 1.8rem;" >↥</a>
</footer>-->
<script type="text/javascript" src="template/linkcitations.js" ></script>
<script type="text/javascript" src="template/linkequation.js" ></script>
<script type="text/javascript" src="template/anchors.js" ></script>
<script type="text/javascript" src="template/copypasteKaTeX.js" ></script>
<script type="text/javascript" src="template/todo.js" ></script>

<!--
<script>
var editing  = false;

if (document.getElementById && document.createElement) {
	var butt = document.createElement('BUTTON');
	var buttext = document.createTextNode('Ready!');
	butt.appendChild(buttext);
	butt.onclick = saveEdit;
}

function catchIt(e) {
	if (editing) return;
	if (!document.getElementById || !document.createElement) return;
	if (!e) var obj = window.event.srcElement;
	else var obj = e.target;
	while (obj.nodeType != 1) {
		obj = obj.parentNode;
	}
	if (obj.tagName == 'TEXTAREA' || obj.tagName == 'A') return;
	while (obj.nodeName != 'P' && obj.nodeName != 'HTML') {
		obj = obj.parentNode;
	}
	if (obj.nodeName == 'HTML') return;
	var x = obj.innerHTML;
	var y = document.createElement('TEXTAREA');
	var z = obj.parentNode;
	z.insertBefore(y,obj);
	z.insertBefore(butt,obj);
	z.removeChild(obj);
	y.value = x;
	y.focus();
	editing = true;
}

function saveEdit() {
	var area = document.getElementsByTagName('TEXTAREA')[0];
	var y = document.createElement('P');
	var z = area.parentNode;
	y.innerHTML = area.value;
	z.insertBefore(y,area);
	z.removeChild(area);
	z.removeChild(document.getElementsByTagName('button')[0]);
	editing = false;
}

document.onclick = catchIt;
</script>
-->
</body>
</html>
